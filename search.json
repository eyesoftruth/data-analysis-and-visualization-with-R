[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Introduction to data analysis and visualization with R",
    "section": "",
    "text": "Welcome\nWelcome to the R Workshop! Get ready to dive into the world of data analysis with R, a powerful tool for crunching numbers and visualizing trends.\nWe’ll start by getting familiar with R and RStudio, the software we’ll use to write and run our code.\nThen, we’ll learn how to bring data into R from different sources like spreadsheets and databases.\nOnce we’ve got our data, we’ll use the tidyverse package to clean it up and get it ready for analysis.\nNext up, we’ll create some awesome charts and graphs with ggplot2, R’s go-to tool for data visualization.\nFinally, we’ll wrap things up by learning how to write reports using RMarkdown, so you can share your findings with others.\nWhether you’re new to R or looking to level up your skills, this workshop has something for everyone. Let’s get started!",
    "crumbs": [
      "Welcome"
    ]
  },
  {
    "objectID": "R_intro.html",
    "href": "R_intro.html",
    "title": "What is R? What is RStudio?",
    "section": "",
    "text": "The term “R” is used to refer to both the programming language and the software that interprets the scripts written using it.\nRStudio is a popular way to write R scripts and interact with the R software. To function correctly, RStudio needs R and therefore both need to be installed on your computer.\n\nKnowing your way around RStudio\n\n\n\n\n\n\nKnowing your way around RStudio\n\n\n\n\n\n\nRStudio is divided into 4 “panes”:\n\nThe Source for your scripts and documents (top-left, in the default layout)\nYour Environment/History (top-right) which shows all the objects in your working space (Environment) and your command history (History)\nYour _Files/Plots/Packages/Help/Viewer (bottom-right)\nThe R Console (bottom-left)\n\n\n\n\n\n\nInteracting with R\n\n\n\n\n\n\nInteracting with R\n\n\n\n\n\nProgramming involves writing instructions for the computer to follow, which are coded in a common language like R that both the computer and humans can understand. These instructions, also known as commands, are executed or run by the computer.\nThere are two primary ways to interact with R: through the console or by using script files, which are plain text files containing code. The console pane, typically located in the bottom left panel of RStudio, allows you to type and immediately execute R commands. However, commands entered directly into the console are not saved when the session is closed.\nTo ensure reproducibility and maintain a record of your work, it’s preferable to type commands in the script editor and save the script. This way, you have a complete record of your actions, and others can easily replicate your results.\nIn RStudio, you can execute commands from the script editor using the Ctrl + Enter shortcut (Cmd + Return on Mac). This sends the command on the current line or all selected text to the console for execution. Additionally, keyboard shortcuts like Ctrl + 1 and Ctrl + 2 allow you to switch between the script and console panes.\nWhen R is ready to accept commands, the console displays a &gt; prompt. After receiving a command, R executes it and displays the results, followed by a new &gt; prompt. If R is still expecting input to complete a command (indicated by a + prompt), you can cancel the incomplete command by pressing Esc.",
    "crumbs": [
      "What is R? What is RStudio?"
    ]
  },
  {
    "objectID": "Introduction_to_R.html",
    "href": "Introduction_to_R.html",
    "title": "Introduction to R",
    "section": "",
    "text": "Intro to basics\nTake your first steps with R. In this chapter, you will learn how to use the console as a calculator and how to assign variables. You will also get to know the basic data types in R. Let’s get started.",
    "crumbs": [
      "Introduction to R"
    ]
  },
  {
    "objectID": "Introduction_to_R.html#intro-to-basics",
    "href": "Introduction_to_R.html#intro-to-basics",
    "title": "Introduction to R",
    "section": "",
    "text": "Creating object in R\n\n\n\n\n\n\nCreating object in R\n\n\n\n\n\nYou can get output from R simply by typing math in the console:\n\n5 + 4\n\n[1] 9\n\n15/3\n\n[1] 5\n\n\nTo perform useful tasks, we often need to assign values to objects in R. To create an object, we specify its name followed by the assignment operator &lt;-, and then provide the desired value:\n\nweight_lb &lt;-  110\nheight_cm = 167\n\nThe assignment operator &lt;- assigns values on the right to objects on the left. For instance, executing x &lt;- 5 results in the value of x being set to 5. While = can also be used to assign a value to an object.\nIn RStudio, on a PC, pressing Alt + - simultaneously will produce &lt;- in a single keystroke. On a Mac, pressing Option + - simultaneously achieves the same result.\n\n\n\n\n\n\nObjects vs. variables\n\n\n\nIn R, what are referred to as objects are commonly known as variables in many other programming languages. Although in different contexts, the terms “object” and “variable” may carry distinct meanings, in this lesson, they are used interchangeably.\n\n\nOnce you created the object you can do arithmetic with it:\n\nheight_cm/100\n\n[1] 1.67\n\n\nYou can also assign a new value to the object:\n\nheight_cm = 176\n\nWe can create a new object from anothr object and creating the new object doesn’t change the value of the other object:\n\nheight_m = height_cm/100\nprint(height_m)\n\n[1] 1.76\n\n\n\n\n\n\n\nSaving your code\n\n\n\n\n\n\nSaving your code\n\n\n\n\n\nSo far, your code has been executed directly in the console, which is convenient for quick queries but less helpful for revisiting your work later on. To create a script file, simply press Ctrl + Shift + N (for Mac Command + Shift + N ). Once your script is open, it’s important to save it right away. You can do this by pressing Ctrl + S (for Mac Command + S), which will prompt a dialogue box where you can choose where to save your script and give it a name. The .R file extension is automatically added, ensuring it opens correctly in RStudio.\nRemember to save your work regularly by pressing Ctrl + S.\n\n\n\n\n\nComments\n\n\n\n\n\n\nComments\n\n\n\n\n\nIn R, the comment character is #. Anything written to the right of a # in a script is disregarded by R, making it helpful for leaving notes and explanations. RStudio offers a keyboard shortcut for commenting or uncommenting a paragraph: after selecting the lines you want to comment, press Ctrl + Shift + C simultaneously. Alternatively, if you only need to comment out one line, you can position the cursor anywhere on that line and then press Ctrl + Shift + C.\n\n\n\n\n\nArithmetic with R\n\n\n\n\n\n\nArithmetic with R\n\n\n\n\n\nIn its most basic form, R can be used as a simple calculator. Consider the following arithmetic operators:\nAddition: +\nSubtraction: -\nMultiplication: *\nDivision: /\nExponentiation: ^\nModulo: %%\nThe last two might need some explaining:\n\nThe ^ operator raises the number to its left to the power of the number to its right: for example 3^2 is 9.\nThe modulo returns the remainder of the division of the number to the left by the number on its right, for example 5 modulo 3 or 5 %% 3 is 2.\n\nWith this knowledge, follow the instructions to complete the exercise.\n\n\n\n\n\n\nInstructions\n\n\n\n\nType 2^5 in the editor to calculate 2 to the power 5.\nType 28 %% 6 to calculate 28 modulo 6.\nHave a look at the R output in the console.\nNote how the # symbol is used to add comments on the R code.\n\n\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\n# An addition\n5 + 5 \n\n[1] 10\n\n# A subtraction\n5 - 5 \n\n[1] 0\n\n# A multiplication\n3 * 5\n\n[1] 15\n\n # A division\n(5 + 5) / 2 \n\n[1] 5\n\n# Exponentiation\n2^5\n\n[1] 32\n\n# Modulo\n28 %% 6\n\n[1] 4\n\n\n\n\n\n\n\n\n\n\nVariable assignment\n\n\n\n\n\n\nVariable assignment\n\n\n\n\n\nA basic concept in (statistical) programming is called a variable.\nA variable allows you to store a value (e.g. 4) or an object (e.g. a function description) in R. You can then later use this variable’s name to easily access the value or the object that is stored within this variable.\nYou can assign a value 4 to a variable my_var with the command\nmy_var &lt;- 4\n\n\n\n\n\n\nInstructions\n\n\n\n\nOver to you: complete the code in the editor such that it assigns the value 42 to the variable x in the editor. Notice that when you ask R to print x, the value 42 appears.\n\n\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\n# Assign the value 42 to x\nx = 42\n\n# Print out the value of the variable x\nprint(x)\n\n[1] 42\n\n\n\n\n\n\n\n\n\n\nVariable assignment (2)\n\n\n\n\n\n\nVariable assignment (2)\n\n\n\n\n\nSuppose you have a fruit basket with five apples. As a data analyst in training, you want to store the number of apples in a variable with the name my_apples.\n\n\n\n\n\n\nInstructions\n\n\n\n\nType the following code in the editor:\nLook at the output: you see that the number 5 is printed. So R now links the variable my_apples to the value 5.\n\n\n# Assign the value 5 to the variable my_apples\nmy_apples = 5\n\n# Print out the value of the variable my_apples\nprint(my_apples)\n\n\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\n# Assign the value 5 to the variable my_apples\nmy_apples = 5\n\n# Print out the value of the variable my_apples\nprint(my_apples)\n\n[1] 5\n\n\n\n\n\n\n\n\n\n\nVariable assignment (3)\n\n\n\n\n\n\nVariable assignment (3)\n\n\n\n\n\nEvery tasty fruit basket needs oranges, so you decide to add six oranges. As a data analyst, your reflex is to immediately create the variable my_oranges and assign the value 6 to it. Next, you want to calculate how many pieces of fruit you have in total. Since you have given meaningful names to these values, you can now code this in a clear way:\nmy_apples + my_oranges\n\n\n\n\n\n\nInstructions\n\n\n\n\nAssign to my_oranges the value 6.\nAdd the variables my_apples and my_oranges and have R simply print the result.\nAssign the result of adding my_apples and my_oranges to a new variable my_fruit.\n\n\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\n# Assign a value to the variables my_apples and my_oranges\nmy_apples = 5\nmy_oranges = 6\n\n# Add these two variables together\nprint(my_apples + my_oranges)\n\n[1] 11\n\n# Create the variable my_fruit\nmy_fruit = my_apples + my_oranges\n\n\n\n\n\n\n\n\n\nApples and oranges\n\n\n\n\n\n\nApples and oranges\n\n\n\n\n\nCommon knowledge tells you not to add apples and oranges. But hey, that is what you just did, no :-)? The my_apples and my_oranges variables both contained a number in the previous exercise. The + operator works with numeric variables in R. If you really tried to add “apples” and “oranges”, and assigned a text value to the variable my_oranges (see the editor), you would be trying to assign the addition of a numeric and a character variable to the variable my_fruit. This is not possible.\n\n\n\n\n\n\nInstructions\n\n\n\n\nSubmit the answer and read the error message. Make sure to understand why this did not work.\nAdjust the code so that R knows you have 6 oranges and thus a fruit basket with 11 pieces of fruit.\n\n\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\n# Assign a value to the variable my_apples\nmy_apples &lt;- 5  \n\n# Fix the assignment of my_oranges\nmy_oranges &lt;- 6\n\n# Create the variable my_fruit and print it out\nmy_fruit &lt;- my_apples + my_oranges \nmy_fruit\n\n[1] 11\n\n\n\n\n\n\n\n\n\n\nBasic data types in R\n\n\n\n\n\n\nBasic data types in R\n\n\n\n\n\nR works with numerous data types. Some of the most basic types to get started are:\nDecimal values like 4.5 are called numerics.\nWhole numbers like 4 are called integers. Integers are also numerics.\nBoolean values (TRUE or FALSE) are called logical.\nText (or string) values are called characters.\nNote how the quotation marks in the editor indicate that “some text” is a string.\n\n\n\n\n\n\nInstructions\n\n\n\nChange the value of the:\n\nmy_numeric variable to 42.\nmy_character variable to “universe”. Note that the quotation marks indicate that “universe” is a character.\nmy_logical variable to FALSE.\n\nNote that R is case sensitive!\n\n\n\n\n\n\n\n\nAnswers\n\n\n\n\n\n\n# Change my_numeric to be 42\nmy_numeric &lt;- 42\n\n# Change my_character to be \"universe\"\nmy_character &lt;- \"universe\"\n\n# Change my_logical to be FALSE\nmy_logical &lt;- FALSE\n\n\n\n\n\n\n\n\n\nWhat’s that data type?\n\n\n\n\n\n\nWhat’s that data type?\n\n\n\n\n\nDo you remember that when you added 5 + “six”, you got an error due to a mismatch in data types? You can avoid such embarrassing situations by checking the data type of a variable beforehand. You can do this with the class() function, as the code in the editor shows.\n\n\n\n\n\n\nInstructions\n\n\n\n\nComplete the code in the editor and also print out the classes of my_character and my_logical.\n\n\n# Declare variables of different types\nmy_numeric &lt;- 42\nmy_character &lt;- \"universe\"\nmy_logical &lt;- FALSE \n\n# Check class of my_numeric\nclass(my_numeric)\n\n\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\n# Declare variables of different types\nmy_numeric &lt;- 42\nmy_character &lt;- \"universe\"\nmy_logical &lt;- FALSE \n\n# Check class of my_numeric\nclass(my_numeric)\n\n[1] \"numeric\"\n\n# Check class of my_character\nclass(my_character)\n\n[1] \"character\"\n\n# Check class of my_logical\nclass(my_logical)\n\n[1] \"logical\"",
    "crumbs": [
      "Introduction to R"
    ]
  },
  {
    "objectID": "Introduction_to_R.html#functions-and-their-arguments",
    "href": "Introduction_to_R.html#functions-and-their-arguments",
    "title": "Introduction to R",
    "section": "Functions and their arguments",
    "text": "Functions and their arguments\n\nWhat are functions?\n\n\n\n\n\n\nWhat are functions?\n\n\n\n\n\nFunctions are “canned scripts” that automate more complicated sets of commands including operations assignments, etc. Many functions are predefined, or can be made available by importing R packages (more on that later). A function usually takes one or more inputs called arguments. Functions often (but not always) return a value. A typical example would be the function sqrt(). The input (the argument) must be a number, and the return value (in fact, the output) is the square root of that number.\n\n\n\n\n\nCalling a function\n\n\n\n\n\n\nCalling a function\n\n\n\n\n\nExecuting a function (‘running it’) is called calling the function. An example of a function call is:\n\nx = sqrt(25)\n\nHere, the value of 10 is given to the sqrt() function, the sqrt() function calculates the square root, and returns the value which is then assigned to the object x\n\n\n\n\n\nFunction argument(s)\n\n\n\n\n\n\nFunction argument\n\n\n\n\n\n\nFunction arguments are the values passed to a function when it is called.\nThey provide the necessary input for the function to perform its task.\nFunctions can have zero or more arguments.\nArguments can be of any data type, such as integers, strings, lists, or even other functions.\n\n\nx = sqrt(21) # 25 is the argument for sqrt()\n\nprint(x)\n\n[1] 4.582576\n\n# Function with multiple argument\nround(x, digits = 2)\n\n[1] 4.58\n\n\n\n\n\n\n\nFunction return value\n\n\n\n\n\n\nFunction return value\n\n\n\n\n\n\nThe return value of a function is the result that the function produces after performing its task.\nIt is the output of the function that is returned to the part of the program that called the function.\nFunctions can return values of any data type, including integers, strings, lists, dictionaries, and more.\nA function may return a single value or multiple values (in the form of tuples or other data structures).\n\n\n# Define a function called add_numbers\nadd_numbers &lt;- function(num1, num2) {\n  sum &lt;- num1 + num2\n  return(sum)\n}\n\n# Call the add_numbers function with arguments 5 and 3\nresult &lt;- add_numbers(5, 3)\nprint(result)  # Output: 8\n\n[1] 8\n\n\nIn this R example, num1 and num2 are the function arguments, and sum is the return value of the add_numbers() function. When the function is called with arguments 5 and 3, it returns the sum of the two numbers, which is then assigned to the variable result and printed.",
    "crumbs": [
      "Introduction to R"
    ]
  },
  {
    "objectID": "Introduction_to_R.html#vectors",
    "href": "Introduction_to_R.html#vectors",
    "title": "Introduction to R",
    "section": "Vectors",
    "text": "Vectors\nIn R, a vector is a fundamental data structure that consists of a sequence of values, which can be either numeric or character. It serves as a versatile container for storing and manipulating data.\n\nCreate a vector\n\n\n\n\n\n\nCreate a vector\n\n\n\n\n\nTo create a vector, you can use the c() function, which concatenates its arguments into a vector.\n\n# Creating a numeric vector\nnumeric_vector &lt;- c(1, 2, 3, 4, 5)\nprint(numeric_vector)\n\n[1] 1 2 3 4 5\n\n# Creating a character vector\ncharacter_vector &lt;- c(\"apple\", \"banana\", \"orange\")\nprint(character_vector)\n\n[1] \"apple\"  \"banana\" \"orange\"\n\n\nThe quotes around “apple”, “banana”, etc. are essential here. Without the quotes R will assume objects have been created called apple, banana and orange As these objects don’t exist in R’s memory, there will be an error message.\n\n\n\n\n\nInspecting a vector\n\n\n\n\n\n\nInspecting a vector\n\n\n\n\n\nIn R, several functions help you inspect the content of a vector:\n\nlength() : Returns the number of elements in a vector.\nclass() : Returns the class or data type of an object.\nstr() : Displays the internal structure of an R object.\nc() : Adds other elements to your vector:\n\nHere’s how you can use these functions with examples:\n\n# Creating a numeric vector\nnumeric_vector = c(1, 2, 3, 4, 5)\n\n# Using length() to determine the number of elements\nprint(length(numeric_vector))\n\n[1] 5\n\n# Using class() to determine the data type\nprint(class(numeric_vector))\n\n[1] \"numeric\"\n\n# Using str() to display the internal structure\nstr(numeric_vector)\n\n num [1:5] 1 2 3 4 5\n\n# Add an element to the numeric_vector\nnumeric_vector = c(numeric_vector, 10)\nprint(numeric_vector)\n\n[1]  1  2  3  4  5 10\n\n\nIn this example, we created a numeric vector numeric_vector and used the length(), class(), and str() functions to inspect its properties. The length() function returns the number of elements in the vector, class() returns its data type (which is “numeric” in this case), and str() displays the structure of the vector, indicating it has 5 numeric elements.\n\n\n\n\n\nTypes of vectors\n\n\n\n\n\n\nTypes of vectors\n\n\n\n\n\nIn R, there are several types of vectors, each suited for different types of data:\n\nNumeric vectors: These vectors contain numeric (integer or decimal) values.\nCharacter vectors: These vectors contain strings of characters.\nLogical vectors: These vectors contain logical (TRUE/FALSE) values.\nInteger vectors: These vectors specifically contain integer values.\nComplex vectors: These vectors contain complex numbers (real and imaginary parts).\nRaw vectors: These vectors contain raw bytes of data.\n\nEach type of vector is optimized for its specific data type and provides different functionalities and operations in R.\nYou can check the type of your vector using the typeof() function and inputting your vector as the argument.\n\ntypeof(numeric_vector)\n\n[1] \"double\"\n\n\n\n\n\n\n\n\nQ:\n\n\n\nWe’ve seen that atomic vectors can be of type character, numeric (or double), integer, and logical. But what happens if we try to mix these types in a single vector?\n\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\nR implicitly converts them to all be the same type\n\n\n\n\n\n\n\n\n\nQ:\n\n\n\n\nWhat will happen in each of these examples? (hint: use class() to check the data type of your objects):\n\n\nnum_char &lt;- c(1, 2, 3, \"a\")\nnum_logical &lt;- c(1, 2, 3, TRUE)\nchar_logical &lt;- c(\"a\", \"b\", \"c\", TRUE)\ntricky &lt;- c(1, 2, 3, \"4\")\n\n\nWhy do you think it happens?\n\n\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\nVectors can be of only one data type. R tries to convert (coerce) the content of this vector to find a “common denominator” that doesn’t lose any information.\n\n\n\n\n\n\n\n\nSubsetting vectors\n\n\n\n\n\n\nSubsetting vectors\n\n\n\n\n\nIf we want to extract one or several values from a vector, we must provide one or several indices in square brackets. For instance:\n\n# Create a numeric vector\nnumbers &lt;- c(10, 20, 30, 40, 50)\n\n# Subsetting using numerical indices\nsubset_numeric &lt;- numbers[c(1, 3, 5)]\nprint(subset_numeric)  # Output: 10 30 50\n\n[1] 10 30 50\n\n# Create a character vector\nfruits &lt;- c(\"apple\", \"banana\", \"orange\", \"mango\", \"grape\")\n\n# Subsetting using numerical indices\nsubset_numeric &lt;- fruits[c(1, 3, 5)]\nprint(subset_numeric)  # Output: \"apple\" \"orange\" \"grape\"\n\n[1] \"apple\"  \"orange\" \"grape\" \n\n\n\n\n\n\n\nConditional subsetting\n\n\n\n\n\n\nConditional subsetting\n\n\n\n\n\nAnother common way of subsetting is by using a logical vector. TRUE will select the element with the same index, while FALSE will not:\n\n# Create a numeric vector\nnumbers &lt;- c(10, 20, 30, 40, 50)\n\n# Subsetting using logical condition\nsubset_condition &lt;- numbers[c(TRUE, FALSE, FALSE, TRUE, TRUE)]\nprint(subset_condition)  # Output: 10 40 50\n\n[1] 10 40 50\n\n\nTypically, these logical vectors are not typed by hand, but are the output of other functions or logical tests. For instance, if you wanted to select only the values above 20:\n\nnumbers &gt; 20\n\n[1] FALSE FALSE  TRUE  TRUE  TRUE\n\n## so we can use this to select only the values above 20\n# Subsetting using logical condition\nsubset_condition &lt;- numbers[numbers &gt; 20]\nprint(subset_condition)  # Output: 30 40 50\n\n[1] 30 40 50\n\n\nYou can combine multiple tests using & (both conditions are true, AND) or | (at least one of the conditions is true, OR):\n\nnumbers&gt;30 & numbers&lt;50\n\n[1] FALSE FALSE FALSE  TRUE FALSE\n\nnumbers[numbers&gt;30 & numbers&lt;50]\n\n[1] 40\n\nnumbers&lt;30 & numbers==50\n\n[1] FALSE FALSE FALSE FALSE FALSE\n\nnumbers[numbers&lt;30 & numbers==50]\n\nnumeric(0)\n\n# Create a character vector\nfruits = c(\"apple\", \"banana\", \"orange\", \"mango\",\"banana\", \"orange\",\"avo\",\"banana\",\"apple\", \"grape\")\n\nfruits[fruits==\"apple\" | fruits == \"orange\"]\n\n[1] \"apple\"  \"orange\" \"orange\" \"apple\" \n\n\nA common task is to search for certain strings in a vector. One could use the “or” operator | to test for equality to multiple values, but this can quickly become tedious. The function %in% allows you to test if any of the elements of a search vector are found:\n\n# Create a character vector\nfruits = c(\"apple\", \"banana\", \"orange\", \"mango\", \"grape\")\n\n\"avo\" %in% fruits\n\n[1] FALSE\n\nc(\"avo\",\"apple\",\"mango\") %in% fruits\n\n[1] FALSE  TRUE  TRUE\n\n\n\n\n\n\n\nMissing data\n\n\n\n\n\n\nMissing data\n\n\n\n\n\nIn R, missing data, represented as NA, is a concept ingrained into the language to accommodate datasets. Unlike many other programming languages, R handles missing data seamlessly within vectors.\nDuring numerical operations, functions typically return NA if any missing values are present in the dataset being analyzed. This behavior ensures that missing data are not overlooked. To calculate results as if missing values were excluded (i.e., removed), you can include the argument na.rm = TRUE. The “rm” in na.rm stands for “ReMoved,” indicating that missing values are removed before computation.\n\nheights &lt;- c(2, 4, 4, NA, 6)\nmean(heights)\n\n[1] NA\n\nmax(heights)\n\n[1] NA\n\nmean(heights, na.rm = TRUE)\n\n[1] 4\n\nmax(heights, na.rm = TRUE)\n\n[1] 6\n\n\nIf your data include missing values, you may want to become familiar with the functions is.na(), na.omit().\n\nheights[!is.na(heights)]\n\n[1] 2 4 4 6\n\nna.omit(heights)\n\n[1] 2 4 4 6\nattr(,\"na.action\")\n[1] 4\nattr(,\"class\")\n[1] \"omit\"",
    "crumbs": [
      "Introduction to R"
    ]
  },
  {
    "objectID": "Introduction_to_R.html#other-data-structures-in-r",
    "href": "Introduction_to_R.html#other-data-structures-in-r",
    "title": "Introduction to R",
    "section": "Other data structures in R",
    "text": "Other data structures in R\n\n\n\n\n\n\nTip\n\n\n\n\n\nIn R, vectors are just one of the many data structures available for organizing and working with data. Let’s briefly explore some of the other essential data structures:\n\n1. Matrices:\nMatrices are two-dimensional arrays where each element is of the same data type. They are created using the matrix() function. Here’s a simple example:\n\n# Create a matrix\nmatrix_data &lt;- matrix(1:9, nrow = 3, ncol = 3)\nprint(matrix_data)\n\n     [,1] [,2] [,3]\n[1,]    1    4    7\n[2,]    2    5    8\n[3,]    3    6    9\n\n\n\n\n2. Lists:\nLists are collections of objects that can be of different types. They are created using the list() function. Here’s an example:\n\n# Create a list\nlist_data &lt;- list(name = \"John\", age = 30, is_student = TRUE)\nprint(list_data)\n\n$name\n[1] \"John\"\n\n$age\n[1] 30\n\n$is_student\n[1] TRUE\n\n\n\n\n3. Arrays:\nArrays are similar to matrices but can have more than two dimensions. They are created using the array() function. Here’s a demonstration:\n\n# Create an array\narray_data &lt;- array(1:12, dim = c(2, 3, 2))\nprint(array_data)\n\n, , 1\n\n     [,1] [,2] [,3]\n[1,]    1    3    5\n[2,]    2    4    6\n\n, , 2\n\n     [,1] [,2] [,3]\n[1,]    7    9   11\n[2,]    8   10   12\n\n\n\n\n4. Data Frames:\nData frames are tabular structures with rows and columns, where each column can have a different data type. They are commonly used for representing datasets. Here’s an example:\n\n# Create a data frame\ndf_data &lt;- data.frame(Name = c(\"Alice\", \"Bob\", \"Charlie\"),\n                      Age = c(25, 30, 35),\n                      Gender = c(\"Female\", \"Male\", \"Male\"))\nprint(df_data)\n\n     Name Age Gender\n1   Alice  25 Female\n2     Bob  30   Male\n3 Charlie  35   Male\n\n\nThese are just a few examples of the many data structures available in R. Understanding these structures and how to work with them is essential for effective data analysis and manipulation in R.",
    "crumbs": [
      "Introduction to R"
    ]
  },
  {
    "objectID": "Introduction_to_R.html#importing-data-into-r",
    "href": "Introduction_to_R.html#importing-data-into-r",
    "title": "Introduction to R",
    "section": "Importing data into R",
    "text": "Importing data into R\n\n\n\n\n\n\nImporting Data into R\n\n\n\n\n\nIn this section, we will learn how to import data into R from text (txt) and comma-separated values (csv) files. Text and CSV files are common formats for storing tabular data, with CSV being a widely used standard due to its simplicity and compatibility with various software applications.\n\nUnderstanding Text (txt) and CSV Files\nText File (txt):\nA text file is a simple file format that stores data as plain text. Each line in a text file typically represents a record, with fields separated by delimiters such as commas, tabs, or spaces.\nComma-Separated Values (CSV) File:\nA CSV file is a type of text file that uses commas to separate values in each row. It’s a popular format for storing spreadsheet or database data and can be easily imported into R using built-in functions.\n\n\nExample: Importing Data from a Text (txt) File\nTo import data from a text file into R, you can use the read.table() function. Let’s assume we have a text file named “data.txt” with tab-separated values (TSV). Here’s how you can import it:\n# Import data from a text file\ndata &lt;- read.table(\"data.txt\", header = TRUE, sep = \"\\t\")\nIn this example, we specify the filename “data.txt”, set header = TRUE to indicate that the first row contains column names, and specify sep = \"\\t\" to indicate that the values are tab-separated.\n\n\nExample: Importing Data from a CSV File\nTo import data from a CSV file into R, you can use the read.csv() function. Let’s assume we have a CSV file named “data.csv”. Here’s how you can import it:\n# Import data from a CSV file\ndata &lt;- read.csv(\"data.csv\")\nIn this example, we simply specify the filename “data.csv”, and R automatically detects the delimiter (comma) and reads the data into a data frame.\n\n\nReading and Exploring a CSV File in R\nWe’ll use the gapminder.csv dataset, which contains information about life expectancy, GDP per capita, and population for various countries over multiple years. The CSV file is in datasets folder.\n\nReading the Data\nNow, let’s read the data from the CSV file into R. We’ll use the read.csv() function for this purpose:\n\n# Read the data from the CSV file\ngapminder = read.csv(\"datasets/gapminder.csv\")\n\nThis command reads the data from ‘gapminder.csv’ and stores it in a data frame named gapminder.\n\n\nExploring the Data\nTo get an overview of the data, let’s first view the first few rows using the head() function:\n\n# View the first few rows of the data\nhead(gapminder)\n\n      country continent year lifeExp      pop gdpPercap\n1 Afghanistan      Asia 1952  28.801  8425333  779.4453\n2 Afghanistan      Asia 1957  30.332  9240934  820.8530\n3 Afghanistan      Asia 1962  31.997 10267083  853.1007\n4 Afghanistan      Asia 1967  34.020 11537966  836.1971\n5 Afghanistan      Asia 1972  36.088 13079460  739.9811\n6 Afghanistan      Asia 1977  38.438 14880372  786.1134\n\n\nThis will display the first six rows of the gapminder dataset, allowing us to inspect the structure and contents of the data.\nNow that we’ve imported the data, let’s understand what each column represents:\n\ncountry: The name of the country.\ncontinent: The continent to which the country belongs.\nyear: The year of observation.\nlifeExp: Life expectancy at birth (in years).\npop: Population.\ngdpPercap: GDP per capita (in USD).",
    "crumbs": [
      "Introduction to R"
    ]
  },
  {
    "objectID": "tidyverse_intro.html",
    "href": "tidyverse_intro.html",
    "title": "Introduction to tidyverse",
    "section": "",
    "text": "The tidyverse package serves as a comprehensive toolkit within R, designed for efficiently transforming and visualizing data. While R offers various toolsets, the tidyverse stands out for its robustness and widespread adoption in data exploration tasks. Throughout this journey, you’ll delve into a dataset known as Gapminder, which tracks key economic and social metrics such as life expectancy and GDP per capita across different countries and time periods. This hands-on experience with Gapminder will equip you with skills for dissecting your own datasets effectively. By mastering the data manipulation and visualization techniques using the ggplot2 package, you’ll learn how to find useful insights and share them with cool plots.\nThis course emphasizes interactivity, blending concise lectures with hands-on exercises where you’ll leverage your coding skills to unravel complex data patterns, all while receiving guidance from our expert instructors along the way.",
    "crumbs": [
      "Introduction to tidyverse"
    ]
  },
  {
    "objectID": "Data_wrangling.html",
    "href": "Data_wrangling.html",
    "title": "Data wrangling",
    "section": "",
    "text": "Loading the gapminder and tidyverse packages\n\n\n\n\n\nBefore you can work with the gapminder dataset, you’ll need to load two R packages that contain the tools for working with it, then display the gapminder dataset so that you can see what it contains.\n\n\n\n\n\n\nExercise\n\n\n\n\nUse the library() function to load the tidyverse package, just like we’ve loaded the gapminder package for you.\nType gapminder, on its own line, to look at the gapminder dataset.\nHow many observations (rows) are in the dataset?\n\n\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\nlibrary(tidyverse)\n\nWarning: package 'ggplot2' was built under R version 4.2.3\n\n\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.2     ✔ readr     2.1.4\n✔ forcats   1.0.0     ✔ stringr   1.5.0\n✔ ggplot2   3.5.0     ✔ tibble    3.2.1\n✔ lubridate 1.9.2     ✔ tidyr     1.3.0\n✔ purrr     1.0.1     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors\n\ngapminder\n\n# A tibble: 1,704 × 6\n   country     continent  year lifeExp      pop gdpPercap\n   &lt;fct&gt;       &lt;fct&gt;     &lt;int&gt;   &lt;dbl&gt;    &lt;int&gt;     &lt;dbl&gt;\n 1 Afghanistan Asia       1952    28.8  8425333      779.\n 2 Afghanistan Asia       1957    30.3  9240934      821.\n 3 Afghanistan Asia       1962    32.0 10267083      853.\n 4 Afghanistan Asia       1967    34.0 11537966      836.\n 5 Afghanistan Asia       1972    36.1 13079460      740.\n 6 Afghanistan Asia       1977    38.4 14880372      786.\n 7 Afghanistan Asia       1982    39.9 12881816      978.\n 8 Afghanistan Asia       1987    40.8 13867957      852.\n 9 Afghanistan Asia       1992    41.7 16317921      649.\n10 Afghanistan Asia       1997    41.8 22227415      635.\n# ℹ 1,694 more rows\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nThe gapminder package\n\n\n\n\n\nThe gapminder object contains structured data in the form of a data frame, which organizes data into rows and columns akin to a spreadsheet or a SQL database table. Data analyses in R, including those in this course, predominantly revolve around data frames. While the gapminder data is presented as a special type of data frame known as a tibble, the distinction is not crucial at this point.\nR initially displays the first ten rows of the data frame, offering a glimpse of its contents along with a brief description. This description indicates that the tibble comprises 1,704 rows, referred to as observations, and six columns, termed variables. Understanding the meaning of each observation, or row, is pivotal in analysis. In this dataset, each observation signifies a unique combination of country and year. For instance, the first observation pertains to Afghanistan’s statistics in 1952, followed by subsequent observations for the same country in different years.\nFor every country-year combination, the dataset provides several variables detailing the country’s demographics. These variables include the continent (e.g., Asia), life expectancy, population, and GDP per capita. GDP per capita denotes a country’s total economic output (Gross Domestic Product) divided by its population, serving as a common metric for assessing a country’s wealth. Each variable adheres to a consistent data type: numeric for measures like life expectancy and population, and categorical for attributes like country and continent.\nEven from this limited view of the data, one can glean insights. For instance, examining Afghanistan’s data reveals an increase in both life expectancy and population over time, while GDP per capita fluctuates. Throughout the course, you’ll learn how to leverage R to draw numerous conclusions about the social and economic histories of countries worldwide.\n\n\n\n\n\n\n\n\n\nVerbs in tidyverse\n\n\n\n\n\nIn the context of the tidyverse, “verbs” refer to the core functions or actions used for data manipulation and transformation. These verbs are part of the dplyr package, which is a key component of the tidyverse ecosystem.\nThe primary verbs in dplyr include:\n\nfilter(): Selects rows of a dataframe based on certain conditions.\nmutate(): Adds new columns or modifies existing ones.\nselect(): Picks specific columns from a dataframe.\narrange(): Sorts rows of a dataframe based on one or more variables.\nsummarize(): Computes summary statistics for groups of rows.\ngroup_by(): Groups the data by one or more variables for further operations.\n\nThese verbs allow for efficient and expressive data manipulation workflows, enabling users to perform common data tasks with ease and clarity.\n\n\n\n\nThe filter verb\nNow that you’re familiar with the gapminder data, you’ll begin learning the tools to manipulate it. In the remainder of this chapter, you’ll delve into the “verbs” within the dplyr package. These verbs represent the fundamental steps used to transform data. The initial verb you’ll explore is filter.\n\n\n\n\n\n\n\nFiltering for one year\n\n\n\n\n\n\ngapminder %&gt;% \n  filter(year == 2007)\n\nA pipe (%&gt;%) is a symbolic representation of “take whatever is before it, and feed it into the next step.” Following the pipe, we can execute our initial verb. In this case, we have data spanning multiple years, but we aim to narrow it down to a single year. Let’s suppose we filter for the year 2007, representing the most recent data in the dataset. The condition “year equals equals 2007” serves as the criterion for filtering observations. The “equals equals” may seem peculiar; it denotes a “logical equals” operation, comparing each year with the value 2007. Using a single equals sign here would yield a different outcome in R, which we’ll explore later. This expression signifies our intention to retain only the observations from 2007.\nExecuting this code results in a dataset containing only 142 rows, corresponding to the number of countries in the dataset. It’s essential to understand that we’re not altering the original gapminder data; it remains intact for other analyses. Instead, the filter function generates a new dataset, with fewer rows, which is then displayed on the screen.\n\n\n\n\n\n\nOutput\n\n\n\n\n\n\ngapminder %&gt;% \n  filter(year == 2007)\n\n# A tibble: 142 × 6\n   country     continent  year lifeExp       pop gdpPercap\n   &lt;fct&gt;       &lt;fct&gt;     &lt;int&gt;   &lt;dbl&gt;     &lt;int&gt;     &lt;dbl&gt;\n 1 Afghanistan Asia       2007    43.8  31889923      975.\n 2 Albania     Europe     2007    76.4   3600523     5937.\n 3 Algeria     Africa     2007    72.3  33333216     6223.\n 4 Angola      Africa     2007    42.7  12420476     4797.\n 5 Argentina   Americas   2007    75.3  40301927    12779.\n 6 Australia   Oceania    2007    81.2  20434176    34435.\n 7 Austria     Europe     2007    79.8   8199783    36126.\n 8 Bahrain     Asia       2007    75.6    708573    29796.\n 9 Bangladesh  Asia       2007    64.1 150448339     1391.\n10 Belgium     Europe     2007    79.4  10392226    33693.\n# ℹ 132 more rows\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFiltering for one country\n\n\n\n\n\nAnother filtering condition could involve selecting observations based on a specific country, in addition to the year. For instance, let’s say we aim to extract data solely from the United States. We express this as “filter country equals equals ‘United States’”, which would yield only the 12 observations corresponding to that country. The quotation marks around ‘United States’ are crucial; without them, R wouldn’t recognize ‘United’ and ‘States’ as the content of a text variable, as opposed to variable names. Unlike numerical values such as 2007, text requires quotation marks for proper interpretation in R.\n\ngapminder %&gt;% \n  filter(country == \"United States\")\n\n\n\n\n\n\n\nOutput\n\n\n\n\n\n\n\n# A tibble: 12 × 6\n   country       continent  year lifeExp       pop gdpPercap\n   &lt;fct&gt;         &lt;fct&gt;     &lt;int&gt;   &lt;dbl&gt;     &lt;int&gt;     &lt;dbl&gt;\n 1 United States Americas   1952    68.4 157553000    13990.\n 2 United States Americas   1957    69.5 171984000    14847.\n 3 United States Americas   1962    70.2 186538000    16173.\n 4 United States Americas   1967    70.8 198712000    19530.\n 5 United States Americas   1972    71.3 209896000    21806.\n 6 United States Americas   1977    73.4 220239000    24073.\n 7 United States Americas   1982    74.6 232187835    25010.\n 8 United States Americas   1987    75.0 242803533    29884.\n 9 United States Americas   1992    76.1 256894189    32004.\n10 United States Americas   1997    76.8 272911760    35767.\n11 United States Americas   2002    77.3 287675526    39097.\n12 United States Americas   2007    78.2 301139947    42952.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFiltering for two variables\n\n\n\n\n\nLastly, we can establish multiple conditions within the filter function. Each condition is separated by a comma. In this context, we’re specifying that we desire only the observation for the year 2007, followed by a comma, indicating where the country is the United States. Each “equals equals” expression constitutes an argument. This dual-filter approach proves beneficial for extracting a singular observation of interest. You’ll have the opportunity to practice this technique in the forthcoming exercises.\n\ngapminder %&gt;% \n  filter(year == 2007, country == \"United States\")\n\n\n\n\n\n\n\nOutput\n\n\n\n\n\n\n\n# A tibble: 1 × 6\n  country       continent  year lifeExp       pop gdpPercap\n  &lt;fct&gt;         &lt;fct&gt;     &lt;int&gt;   &lt;dbl&gt;     &lt;int&gt;     &lt;dbl&gt;\n1 United States Americas   2007    78.2 301139947    42952.\n\n\n\n\n\n\n\n\n\n\nExercise: the filter verb\n\n\n\n\n\n\nExercise : Filtering for one year\n\n\n\nThe filter verb extracts particular observations based on a condition. In this exercise you’ll filter for observations from a particular year.\n\nAdd a filter() line after the pipe (%&gt;%) to extract only the observations from the year 1957. Remember that you use == to compare two values.\n\n\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\n# Filter the gapminder dataset for the year 1957\ngapminder %&gt;%\nfilter(year == 1957)\n\n# A tibble: 142 × 6\n   country     continent  year lifeExp      pop gdpPercap\n   &lt;fct&gt;       &lt;fct&gt;     &lt;int&gt;   &lt;dbl&gt;    &lt;int&gt;     &lt;dbl&gt;\n 1 Afghanistan Asia       1957    30.3  9240934      821.\n 2 Albania     Europe     1957    59.3  1476505     1942.\n 3 Algeria     Africa     1957    45.7 10270856     3014.\n 4 Angola      Africa     1957    32.0  4561361     3828.\n 5 Argentina   Americas   1957    64.4 19610538     6857.\n 6 Australia   Oceania    1957    70.3  9712569    10950.\n 7 Austria     Europe     1957    67.5  6965860     8843.\n 8 Bahrain     Asia       1957    53.8   138655    11636.\n 9 Bangladesh  Asia       1957    39.3 51365468      662.\n10 Belgium     Europe     1957    69.2  8989111     9715.\n# ℹ 132 more rows\n\n\n\n\n\n\n\n\n\n\n\nExercise: Filtering for one coutry and one year\n\n\n\nYou can also use the filter() verb to set two conditions, which could retrieve a single observation.\nJust like in the last exercise, you can do this in two lines of code, starting with gapminder %&gt;% and having the filter() on the second line. Keeping one verb on each line helps keep the code readable. Note that each time, you’ll put the pipe %&gt;% at the end of the first line (like gapminder %&gt;%); putting the pipe at the beginning of the second line will throw an error.\n\nFilter the gapminder data to retrieve only the observation from China in the year 2002.\n\n\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\n# Filter for China in 2002\ngapminder%&gt;% \nfilter(country=='China', year==2002)\n\n# A tibble: 1 × 6\n  country continent  year lifeExp        pop gdpPercap\n  &lt;fct&gt;   &lt;fct&gt;     &lt;int&gt;   &lt;dbl&gt;      &lt;int&gt;     &lt;dbl&gt;\n1 China   Asia       2002    72.0 1280400000     3119.\n\n\n\n\n\n\n\nThe arrange verb\narrange sorts the observations in a dataset, in ascending or descending order based on one of its variables. This is useful, for example, when you want to know the most extreme values in a dataset.\n\n\n\n\n\n\n\nSorting with arrange\n\n\n\n\n\nSimilar to the filter verb, you utilize the arrange verb after the pipe operator in R. You would specify the gapminder object, followed by the pipe operator (%&gt;%), and then arrange. Inside the parentheses of arrange, you indicate the column by which you want to sort the observations.\n\ngapminder %&gt;% \n  arrange(gdpPercap)\n\n\n\n\n\n\n\nOutput\n\n\n\n\n\n\ngapminder %&gt;% \n  arrange(gdpPercap)\n\n# A tibble: 1,704 × 6\n   country          continent  year lifeExp      pop gdpPercap\n   &lt;fct&gt;            &lt;fct&gt;     &lt;int&gt;   &lt;dbl&gt;    &lt;int&gt;     &lt;dbl&gt;\n 1 Congo, Dem. Rep. Africa     2002    45.0 55379852      241.\n 2 Congo, Dem. Rep. Africa     2007    46.5 64606759      278.\n 3 Lesotho          Africa     1952    42.1   748747      299.\n 4 Guinea-Bissau    Africa     1952    32.5   580653      300.\n 5 Congo, Dem. Rep. Africa     1997    42.6 47798986      312.\n 6 Eritrea          Africa     1952    35.9  1438760      329.\n 7 Myanmar          Asia       1952    36.3 20092996      331 \n 8 Lesotho          Africa     1957    45.0   813338      336.\n 9 Burundi          Africa     1952    39.0  2445618      339.\n10 Eritrea          Africa     1957    38.0  1542611      344.\n# ℹ 1,694 more rows\n\n\n\n\n\nAfter executing this, the observations are arranged in ascending order based on the specified column, with the lowest GDP per capita appearing first. Take note of the rightmost column: observe that it begins with 241, the smallest value in the dataset, and increases thereafter. From this, it’s evident that the country-year pair with the lowest GDP per capita was the Democratic Republic of the Congo in 2002.\nJust like with filter, the original gapminder object remains unchanged; arrange simply provides you with a new dataset that is sorted accordingly.\n\n\n\n\n\n\n\n\n\nSorting in descending order\n\n\n\n\n\nArrange also lets you sort in descending order. To achieve that, you would encapsulate the variable you’re sorting by within desc() for descending order. This approach enables us to identify that the country-year pair with the highest GDP per capita was Kuwait in the year 1957.\n\ngapminder %&gt;% \n  arrange(desc(gdpPercap))\n\n\n\n\n\n\n\nOutput\n\n\n\n\n\n\ngapminder %&gt;% \n  arrange(desc(gdpPercap))\n\n# A tibble: 1,704 × 6\n   country   continent  year lifeExp     pop gdpPercap\n   &lt;fct&gt;     &lt;fct&gt;     &lt;int&gt;   &lt;dbl&gt;   &lt;int&gt;     &lt;dbl&gt;\n 1 Kuwait    Asia       1957    58.0  212846   113523.\n 2 Kuwait    Asia       1972    67.7  841934   109348.\n 3 Kuwait    Asia       1952    55.6  160000   108382.\n 4 Kuwait    Asia       1962    60.5  358266    95458.\n 5 Kuwait    Asia       1967    64.6  575003    80895.\n 6 Kuwait    Asia       1977    69.3 1140357    59265.\n 7 Norway    Europe     2007    80.2 4627926    49357.\n 8 Kuwait    Asia       2007    77.6 2505559    47307.\n 9 Singapore Asia       2007    80.0 4553009    47143.\n10 Norway    Europe     2002    79.0 4535591    44684.\n# ℹ 1,694 more rows\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFiltering then arranging\n\n\n\n\n\nExamining all countries and years simultaneously might not be particularly informative. Suppose you were interested in identifying the countries with the highest GDP per capita for a specific year. To do that, you can combine the two verbs you’ve already learned: filter, and arrange. You start with the gapminder dataset, then a pipe to give the dataset to filter. Then you specify that you want to filter for year equals equals 2007. Then you use another pipe. This takes the result of the filter, and gives it to arrange. You specify that you want to sort in descending order of GDP per capita. This shows you that the countries with the highest GDP per capita in 2007 were Norway, Kuwait, Singapore, and the United States. We can explore many such questions with various combinations of dplyr verbs. Over the course of these lessons, you’ll learn to pipe together multiple simple operations to create a rich and informative data analysis.\n\ngapminder %&gt;% \n  filter(year == 2007) %&gt;% \n  arrange(desc(gdpPercap))\n\n\n\n\n\n\n\nOutput\n\n\n\n\n\n\n\n# A tibble: 142 × 6\n   country          continent  year lifeExp       pop gdpPercap\n   &lt;fct&gt;            &lt;fct&gt;     &lt;int&gt;   &lt;dbl&gt;     &lt;int&gt;     &lt;dbl&gt;\n 1 Norway           Europe     2007    80.2   4627926    49357.\n 2 Kuwait           Asia       2007    77.6   2505559    47307.\n 3 Singapore        Asia       2007    80.0   4553009    47143.\n 4 United States    Americas   2007    78.2 301139947    42952.\n 5 Ireland          Europe     2007    78.9   4109086    40676.\n 6 Hong Kong, China Asia       2007    82.2   6980412    39725.\n 7 Switzerland      Europe     2007    81.7   7554661    37506.\n 8 Netherlands      Europe     2007    79.8  16570613    36798.\n 9 Canada           Americas   2007    80.7  33390141    36319.\n10 Iceland          Europe     2007    81.8    301931    36181.\n# ℹ 132 more rows\n\n\n\n\n\n\n\n\n\n\nExercise: the arrange verb\n\n\n\n\n\n\nExercise: Arranging observations by life expectancy\n\n\n\nYou use arrange() to sort observations in ascending or descending order of a particular variable. In this case, you’ll sort the dataset based on the lifeExp variable.\n\nSort the gapminder dataset in ascending order of life expectancy (lifeExp).\nSort the gapminder dataset in descending order of life expectancy.\n\n\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\n# Sort in ascending order of lifeExp\n\ngapminder%&gt;%\n    arrange(lifeExp)\n\n# A tibble: 1,704 × 6\n   country      continent  year lifeExp     pop gdpPercap\n   &lt;fct&gt;        &lt;fct&gt;     &lt;int&gt;   &lt;dbl&gt;   &lt;int&gt;     &lt;dbl&gt;\n 1 Rwanda       Africa     1992    23.6 7290203      737.\n 2 Afghanistan  Asia       1952    28.8 8425333      779.\n 3 Gambia       Africa     1952    30    284320      485.\n 4 Angola       Africa     1952    30.0 4232095     3521.\n 5 Sierra Leone Africa     1952    30.3 2143249      880.\n 6 Afghanistan  Asia       1957    30.3 9240934      821.\n 7 Cambodia     Asia       1977    31.2 6978607      525.\n 8 Mozambique   Africa     1952    31.3 6446316      469.\n 9 Sierra Leone Africa     1957    31.6 2295678     1004.\n10 Burkina Faso Africa     1952    32.0 4469979      543.\n# ℹ 1,694 more rows\n\n# Sort in descending order of lifeExp\n\ngapminder%&gt;%\n    arrange(desc(lifeExp))\n\n# A tibble: 1,704 × 6\n   country          continent  year lifeExp       pop gdpPercap\n   &lt;fct&gt;            &lt;fct&gt;     &lt;int&gt;   &lt;dbl&gt;     &lt;int&gt;     &lt;dbl&gt;\n 1 Japan            Asia       2007    82.6 127467972    31656.\n 2 Hong Kong, China Asia       2007    82.2   6980412    39725.\n 3 Japan            Asia       2002    82   127065841    28605.\n 4 Iceland          Europe     2007    81.8    301931    36181.\n 5 Switzerland      Europe     2007    81.7   7554661    37506.\n 6 Hong Kong, China Asia       2002    81.5   6762476    30209.\n 7 Australia        Oceania    2007    81.2  20434176    34435.\n 8 Spain            Europe     2007    80.9  40448191    28821.\n 9 Sweden           Europe     2007    80.9   9031088    33860.\n10 Israel           Asia       2007    80.7   6426679    25523.\n# ℹ 1,694 more rows\n\n\n\n\n\n\n\n\n\n\n\nExercise: Filtering and arranging\n\n\n\nYou’ll often need to use the pipe operator (%&gt;%) to combine multiple dplyr verbs in a row. In this case, you’ll combine a filter() with an arrange() to find the highest population countries in a particular year.\n\nUse filter() to extract observations from just the year 1957, then use arrange() to sort in descending order of population (pop).\n\n\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\n# Filter for the year 1957, then arrange in descending order of population\n\ngapminder%&gt;%\n    filter(year==1957)%&gt;%\n    arrange(desc(pop))\n\n# A tibble: 142 × 6\n   country        continent  year lifeExp       pop gdpPercap\n   &lt;fct&gt;          &lt;fct&gt;     &lt;int&gt;   &lt;dbl&gt;     &lt;int&gt;     &lt;dbl&gt;\n 1 China          Asia       1957    50.5 637408000      576.\n 2 India          Asia       1957    40.2 409000000      590.\n 3 United States  Americas   1957    69.5 171984000    14847.\n 4 Japan          Asia       1957    65.5  91563009     4318.\n 5 Indonesia      Asia       1957    39.9  90124000      859.\n 6 Germany        Europe     1957    69.1  71019069    10188.\n 7 Brazil         Americas   1957    53.3  65551171     2487.\n 8 United Kingdom Europe     1957    70.4  51430000    11283.\n 9 Bangladesh     Asia       1957    39.3  51365468      662.\n10 Italy          Europe     1957    67.8  49182000     6249.\n# ℹ 132 more rows\n\n\n\n\n\n\n\nThe mutate verb\nThe mutate verb is used to create new columns or modify existing columns in a data frame. It allows you to apply functions or operations to each row of the data frame to generate new values for the specified columns.\n\n\n\n\n\n\n\nUsing mutate to change a variable\n\n\n\n\n\n\ngapminder %&gt;% \n  mutate(pop = pop/1000000)\n\nSimilar to filter or arrange, you use mutate after a pipe operator in R. Inside the mutate statement, what’s on the right of the equals sign is what’s being calculated, while what’s on the left is what’s being replaced. In this example, you’re calculating “population divided by one million” using the slash operator for division. On the left, you’re indicating that you want to replace the existing pop column by writing pop =.\nAs a result, you obtain the same table, but with the pop column replaced by a new value, one that’s much smaller than it was before. This demonstrates how you can manipulate existing variables in the table, a task often required during data processing and cleaning. Like filter and arrange, you’re not modifying the original gapminder data; instead, you’re altering the value in the new data frame that’s being returned.\n\n\n\n\n\n\nOutput\n\n\n\n\n\n\ngapminder %&gt;% \n  mutate(pop = pop/1000000)\n\n# A tibble: 1,704 × 6\n   country     continent  year lifeExp   pop gdpPercap\n   &lt;fct&gt;       &lt;fct&gt;     &lt;int&gt;   &lt;dbl&gt; &lt;dbl&gt;     &lt;dbl&gt;\n 1 Afghanistan Asia       1952    28.8  8.43      779.\n 2 Afghanistan Asia       1957    30.3  9.24      821.\n 3 Afghanistan Asia       1962    32.0 10.3       853.\n 4 Afghanistan Asia       1967    34.0 11.5       836.\n 5 Afghanistan Asia       1972    36.1 13.1       740.\n 6 Afghanistan Asia       1977    38.4 14.9       786.\n 7 Afghanistan Asia       1982    39.9 12.9       978.\n 8 Afghanistan Asia       1987    40.8 13.9       852.\n 9 Afghanistan Asia       1992    41.7 16.3       649.\n10 Afghanistan Asia       1997    41.8 22.2       635.\n# ℹ 1,694 more rows\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nUsing mutate to add a new variable\n\n\n\n\n\nAlternatively, you might want to introduce a new variable. For example, you currently have the GDP per capita, which is the Gross Domestic Product of the country divided by the current population. However, for your analysis, you might be interested in knowing the total GDP. To obtain this, you would multiply the population by the GDP per capita.\nYou would use mutate in a similar manner as before. You pipe your gapminder data to the mutate verb. In R, the asterisk represents multiplication, so you write gdpPercap * pop to multiply the two columns. It’s worth noting that for clarity, we’ve named the new column gdp, which appears to the left of the equals sign in our code. Column names must be single words without spaces.\n\ngapminder %&gt;% \n  mutate(gdp = gdpPercap * pop)\n\n\n\n\n\n\n\nOutput\n\n\n\n\n\n\n\n# A tibble: 1,704 × 7\n   country     continent  year lifeExp      pop gdpPercap          gdp\n   &lt;fct&gt;       &lt;fct&gt;     &lt;int&gt;   &lt;dbl&gt;    &lt;int&gt;     &lt;dbl&gt;        &lt;dbl&gt;\n 1 Afghanistan Asia       1952    28.8  8425333      779.  6567086330.\n 2 Afghanistan Asia       1957    30.3  9240934      821.  7585448670.\n 3 Afghanistan Asia       1962    32.0 10267083      853.  8758855797.\n 4 Afghanistan Asia       1967    34.0 11537966      836.  9648014150.\n 5 Afghanistan Asia       1972    36.1 13079460      740.  9678553274.\n 6 Afghanistan Asia       1977    38.4 14880372      786. 11697659231.\n 7 Afghanistan Asia       1982    39.9 12881816      978. 12598563401.\n 8 Afghanistan Asia       1987    40.8 13867957      852. 11820990309.\n 9 Afghanistan Asia       1992    41.7 16317921      649. 10595901589.\n10 Afghanistan Asia       1997    41.8 22227415      635. 14121995875.\n# ℹ 1,694 more rows\n\n\n\n\n\nUpon inspecting the results, you’ll observe a brand new gdp column, significantly larger than the GDP per capita.\n\n\n\n\n\n\n\n\n\nCombining verbs\n\n\n\n\n\nLet’s integrate the three verbs you’ve learned in this chapter to address a question about our data. Suppose we aim to identify the countries with the highest total GDP in the year 2007. We can accomplish this in three steps: creating the column, filtering for 2007, and then sorting.\n\ngapminder %&gt;% \n  mutate(gdp = gdpPercap * pop) %&gt;% \n  filter(year == 2007) %&gt;% \n  arrange(desc(gdp))\n\nFirstly, we utilize mutate to generate the total GDP column. Next, we employ filter to confine our analysis solely to the year 2007. Lastly, we utilize arrange to arrange the data in descending order based on our newly created GDP variable. This sequence furnishes us with the desired answer.\nIn 2007, the United States emerged as the country with the highest total GDP, amounting to 13 trillion dollars. Following the US are China, Japan, India, and Germany, ranking among the top GDP countries. As you become proficient with dplyr, you’ll be equipped to explore answers to such questions and tackle even more complex inquiries using your own data.\n\n\n\n\n\n\nOutput\n\n\n\n\n\n\ngapminder %&gt;% \n  mutate(gdp = gdpPercap * pop) %&gt;% \n  filter(year == 2007) %&gt;% \n  arrange(desc(gdp))\n\n# A tibble: 142 × 7\n   country        continent  year lifeExp        pop gdpPercap     gdp\n   &lt;fct&gt;          &lt;fct&gt;     &lt;int&gt;   &lt;dbl&gt;      &lt;int&gt;     &lt;dbl&gt;   &lt;dbl&gt;\n 1 United States  Americas   2007    78.2  301139947    42952. 1.29e13\n 2 China          Asia       2007    73.0 1318683096     4959. 6.54e12\n 3 Japan          Asia       2007    82.6  127467972    31656. 4.04e12\n 4 India          Asia       2007    64.7 1110396331     2452. 2.72e12\n 5 Germany        Europe     2007    79.4   82400996    32170. 2.65e12\n 6 United Kingdom Europe     2007    79.4   60776238    33203. 2.02e12\n 7 France         Europe     2007    80.7   61083916    30470. 1.86e12\n 8 Brazil         Americas   2007    72.4  190010647     9066. 1.72e12\n 9 Italy          Europe     2007    80.5   58147733    28570. 1.66e12\n10 Mexico         Americas   2007    76.2  108700891    11978. 1.30e12\n# ℹ 132 more rows\n\n\n\n\n\n\n\n\n\n\nExercise: the mutate verb\n\n\n\n\n\n\nExercise: Using mutate to change or create a column\n\n\n\nSuppose we want life expectancy to be measured in months instead of years: you’d have to multiply the existing value by 12. You can use the mutate() verb to change this column, or to create a new column that’s calculated this way.\n\nUse mutate() to change the existing lifeExp column, by multiplying it by 12: 12 * lifeExp.\nUse mutate() to add a new column, called lifeExpMonths, calculated as 12 * lifeExp.\n\n\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\n# Use mutate to change lifeExp to be in months\n\ngapminder%&gt;%\n    mutate(lifeExp = lifeExp*12)\n\n# A tibble: 1,704 × 6\n   country     continent  year lifeExp      pop gdpPercap\n   &lt;fct&gt;       &lt;fct&gt;     &lt;int&gt;   &lt;dbl&gt;    &lt;int&gt;     &lt;dbl&gt;\n 1 Afghanistan Asia       1952    346.  8425333      779.\n 2 Afghanistan Asia       1957    364.  9240934      821.\n 3 Afghanistan Asia       1962    384. 10267083      853.\n 4 Afghanistan Asia       1967    408. 11537966      836.\n 5 Afghanistan Asia       1972    433. 13079460      740.\n 6 Afghanistan Asia       1977    461. 14880372      786.\n 7 Afghanistan Asia       1982    478. 12881816      978.\n 8 Afghanistan Asia       1987    490. 13867957      852.\n 9 Afghanistan Asia       1992    500. 16317921      649.\n10 Afghanistan Asia       1997    501. 22227415      635.\n# ℹ 1,694 more rows\n\n# Use mutate to create a new column called lifeExpMonths\ngapminder%&gt;%\n    mutate(lifeExpMonths=lifeExp*12)\n\n# A tibble: 1,704 × 7\n   country     continent  year lifeExp      pop gdpPercap lifeExpMonths\n   &lt;fct&gt;       &lt;fct&gt;     &lt;int&gt;   &lt;dbl&gt;    &lt;int&gt;     &lt;dbl&gt;         &lt;dbl&gt;\n 1 Afghanistan Asia       1952    28.8  8425333      779.          346.\n 2 Afghanistan Asia       1957    30.3  9240934      821.          364.\n 3 Afghanistan Asia       1962    32.0 10267083      853.          384.\n 4 Afghanistan Asia       1967    34.0 11537966      836.          408.\n 5 Afghanistan Asia       1972    36.1 13079460      740.          433.\n 6 Afghanistan Asia       1977    38.4 14880372      786.          461.\n 7 Afghanistan Asia       1982    39.9 12881816      978.          478.\n 8 Afghanistan Asia       1987    40.8 13867957      852.          490.\n 9 Afghanistan Asia       1992    41.7 16317921      649.          500.\n10 Afghanistan Asia       1997    41.8 22227415      635.          501.\n# ℹ 1,694 more rows\n\n\n\n\n\n\n\n\n\n\n\nExercise: Combining filter, mutate, and arrange\n\n\n\nIn this exercise, you’ll combine all three of the verbs you’ve learned in this chapter, to find the countries with the highest life expectancy, in months, in the year 2007.\n\nIn one sequence of pipes on the gapminder dataset:\nfilter() for observations from the year 2007,\nmutate() to create a column lifeExpMonths, calculated as 12 * lifeExp, and\narrange() in descending order of that new column\n\n\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\n# Filter for the year 1957, \n# mutate to change lifeExp to be in months\n# then arrange in descending order of population\n\ngapminder%&gt;%\n  filter(year == 1957) %&gt;% \n  mutate(lifeExpMonths = lifeExp*12) %&gt;% \n  arrange(lifeExpMonths)\n\n# A tibble: 142 × 7\n   country       continent  year lifeExp     pop gdpPercap lifeExpMonths\n   &lt;fct&gt;         &lt;fct&gt;     &lt;int&gt;   &lt;dbl&gt;   &lt;int&gt;     &lt;dbl&gt;         &lt;dbl&gt;\n 1 Afghanistan   Asia       1957    30.3 9240934      821.          364.\n 2 Sierra Leone  Africa     1957    31.6 2295678     1004.          379.\n 3 Angola        Africa     1957    32.0 4561361     3828.          384.\n 4 Gambia        Africa     1957    32.1  323150      521.          385.\n 5 Guinea-Bissau Africa     1957    33.5  601095      432.          402.\n 6 Mozambique    Africa     1957    33.8 7038035      496.          405.\n 7 Yemen, Rep.   Asia       1957    34.0 5498090      805.          408.\n 8 Guinea        Africa     1957    34.6 2876726      576.          415.\n 9 Burkina Faso  Africa     1957    34.9 4713416      617.          419.\n10 Somalia       Africa     1957    35.0 2780415     1258.          420.\n# ℹ 132 more rows",
    "crumbs": [
      "Data wrangling"
    ]
  },
  {
    "objectID": "Data_visualization.html",
    "href": "Data_visualization.html",
    "title": "Data visualization",
    "section": "",
    "text": "Variable Assignment",
    "crumbs": [
      "Data visualization"
    ]
  },
  {
    "objectID": "Data_visualization.html#variable-assignment",
    "href": "Data_visualization.html#variable-assignment",
    "title": "Data visualization",
    "section": "",
    "text": "Variable Assignment\n\n\n\n\n\nThroughout this chapter, your focus will primarily be on visualizing subsets of the gapminder dataset. For instance, you’ll frequently visualize data from specific years, like 2007. When you’re working with such subsets, it’s beneficial to preserve the filtered data by storing it as a new data frame. To accomplish this, you employ the assignment operator, which resembles an arrow pointing to the left. In this operation, you filter the gapminder dataset for observations from the year 2007 and save it into a dataset named gapminder_2007.\n\ngapminder_2007 = gapminder %&gt;% \n                  filter(year == 2007)\ngapminder_2007  \n\n\n\n\n\n\n\nOutput\n\n\n\n\n\n\n\n# A tibble: 142 × 6\n   country     continent  year lifeExp       pop gdpPercap\n   &lt;fct&gt;       &lt;fct&gt;     &lt;int&gt;   &lt;dbl&gt;     &lt;int&gt;     &lt;dbl&gt;\n 1 Afghanistan Asia       2007    43.8  31889923      975.\n 2 Albania     Europe     2007    76.4   3600523     5937.\n 3 Algeria     Africa     2007    72.3  33333216     6223.\n 4 Angola      Africa     2007    42.7  12420476     4797.\n 5 Argentina   Americas   2007    75.3  40301927    12779.\n 6 Australia   Oceania    2007    81.2  20434176    34435.\n 7 Austria     Europe     2007    79.8   8199783    36126.\n 8 Bahrain     Asia       2007    75.6    708573    29796.\n 9 Bangladesh  Asia       2007    64.1 150448339     1391.\n10 Belgium     Europe     2007    79.4  10392226    33693.\n# ℹ 132 more rows\n\n\n\n\n\nUpon printing the gapminder_2007 dataset, you’ll observe that it’s another table. However, this one comprises only 142 rows, representing data solely from the year 2007. Now that you’ve retained this variable, you can utilize it to construct your visualization.",
    "crumbs": [
      "Data visualization"
    ]
  },
  {
    "objectID": "Data_visualization.html#visualizing-with-ggplot2",
    "href": "Data_visualization.html#visualizing-with-ggplot2",
    "title": "Data visualization",
    "section": "Visualizing with ggplot2",
    "text": "Visualizing with ggplot2\n\n\n\n\n\n\nVisualizing with ggplot2\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSuppose you aim to explore the correlation between a country’s wealth and its life expectancy. This can be achieved through a scatterplot comparing two variables in our gapminder dataset: GDP per capita on the X-axis and life expectancy on the Y-axis. You’ll generate this plot using the ggplot2 package. Similar to the gapminder and dplyr packages, you’ll need to load it with library(ggplot2) first.\n\nlibrary(ggplot2)\nggplot(data = gapminder_2007, aes(x = gdpPercap, y = lifeExp)) +\n  geom_point()\n\nThere are three components to a ggplot graph. Firstly, the data that you’re visualizing—here, it’s the gapminder_2007 variable you just created. Secondly, the mapping of variables in your dataset to aesthetics in your graph. An aesthetic represents a visual dimension of a graph that communicates information. In a scatterplot, the X-axis and the Y-axis are the two dimensions, which you specify using aes(x = gdpPercap, y = lifeExp). Lastly, you specify the type of graph you’re creating by adding a layer to the graph using geom_point(). The term “geom” signifies that you’re adding a type of geometric object to the graph, while “point” indicates it’s a scatter plot where each observation corresponds to one point.\nTogether, these three parts of the code—the data, the aesthetic mapping, and the layer—construct the scatter plot. In the exercises, you’ll practice generating other scatterplots to compare variables across countries. Additionally, throughout the rest of this chapter, you’ll learn more techniques to effectively communicate information through graphs.\n\n\n\n\nExercise\n\n\n\n\n\n\nExercise: Variable assignment\n\n\n\nThroughout the exercises in this chapter, you’ll be visualizing a subset of the gapminder data from the year 1952. First, you’ll have to load the ggplot2 package, and create a gapminder_1952 dataset to visualize.\n\nLoad the ggplot2 package after the gapminder and dplyr packages.\nFilter gapminder for observations from the year 1952, and assign it to a new dataset gapminder_1952 using the assignment operator (&lt;-).\n\n\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\n# Create gapminder_1952\ngapminder_1952 = gapminder%&gt;%\n                    filter(year == 1952)\n\n\n\n\n\n\n\n\n\n\nExercise: Comparing population and GDP per capita\n\n\n\nEarlier, you learned to create a scatter plot with GDP per capita on the x-axis and life expectancy on the y-axis (the code for that graph has been provided in the exercise code). When you’re exploring data visually, you’ll often need to try different combinations of variables and aesthetics.\n\nChange the scatter plot of gapminder_1952 so that (pop) is on the x-axis and GDP per capita (gdpPercap) is on the y-axis.\n\n\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\ngapminder_1952 &lt;- gapminder %&gt;%\n  filter(year == 1952)\n\n# Change to put pop on the x-axis and gdpPercap on the y-axis\nggplot(gapminder_1952, aes(x= pop,y = gdpPercap)) +\n  geom_point()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nExercise: Comparing population and life expectancy\n\n\n\nIn this exercise, you’ll use ggplot2 to create a scatter plot from scratch, to compare each country’s population with its life expectancy in the year 1952.\n\nCreate a scatter plot of gapminder_1952 with population (pop) is on the x-axis and life expectancy (lifeExp) on the y-axis.\n\n\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\ngapminder_1952 &lt;- gapminder %&gt;%\n  filter(year == 1952)\n\n# Create a scatter plot with pop on the x-axis and lifeExp on the y-axis\nggplot(gapminder_1952,aes(x=pop, y = lifeExp))+\n  geom_point()",
    "crumbs": [
      "Data visualization"
    ]
  },
  {
    "objectID": "Data_visualization.html#log-scales",
    "href": "Data_visualization.html#log-scales",
    "title": "Data visualization",
    "section": "Log scales",
    "text": "Log scales\n\n\n\n\n\n\nLog scales\n\n\n\n\n\nIn the previous lesson, you generated a scatter plot comparing the GDP per capita of each country to its life expectancy. This plot reveals some intriguing insights: notably, higher-income countries tend to exhibit higher life expectancy. However, one drawback of this plot is that many countries appear clustered in the leftmost part of the x-axis. This clustering occurs because the distribution of GDP per capita spans several orders of magnitude, with some countries having values in the tens of thousands of dollars while others have values in the hundreds. When dealing with such a wide-ranging distribution on one axis, it’s beneficial to utilize a logarithmic scale—a scale where each fixed distance represents a multiplication of the value.\n\nlibrary(ggplot2)\nggplot(data = gapminder_2007, aes(x = gdpPercap, y = lifeExp)) +\n  geom_point()\n\n\n\n\n\n\n\n\nBelow is how the scatter plot appears when the x-axis is on a log scale. While it’s the same data, each unit on the x-axis now represents a tenfold change in GDP. You’ll notice that the axis spans from one thousand to ten thousand, and the subsequent step of equal distance would be one hundred thousand. With this scale, the relationship between GDP per capita and life expectancy appears more linear, and it becomes easier to distinguish countries at the lower end of the spectrum.\n\n\n\n\n\n\n\n\n\nTo create this graph, you simply add an additional option to your ggplot call, following another “+” after geom_point. Specifically, you include scale_x_log10. This specifies that the x-axis should be on a log10 scale. While it’s not necessary in this scenario, if you wish to put the y-axis on a log scale as well, you would use scale_y_log10.\n\nlibrary(ggplot2)\nggplot(data = gapminder_2007, aes(x = gdpPercap, y = lifeExp)) +\n  geom_point()+ \n  scale_x_log10()\n\n\n\n\n\nExercise: Log scales\n\n\n\n\n\n\nExercise: Putting the x-axis on a log scale\n\n\n\nYou previously created a scatter plot with population on the x-axis and life expectancy on the y-axis. Since population is spread over several orders of magnitude, with some countries having a much higher population than others, it’s a good idea to put the x-axis on a log scale.\n\nChange the existing scatter plot (code provided) to put the x-axis (representing population) on a log scale.\n\n\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\ngapminder_1952 &lt;- gapminder %&gt;%\n  filter(year == 1952)\n\n# Change this plot to put the x-axis on a log scale\nggplot(gapminder_1952, aes(x = pop, y = lifeExp)) +\n  geom_point() + scale_x_log10()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nExercise: Putting the x- and y- axes on a log scale\n\n\n\nSuppose you want to create a scatter plot with population on the x-axis and GDP per capita on the y-axis. Both population and GDP per-capita are better represented with log scales, since they vary over many orders of magnitude.\n\nCreate a scatter plot with population (pop) on the x-axis and GDP per capita (gdpPercap) on the y-axis. Put both the x- and y- axes on a log scale.\n\n\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\ngapminder_1952 &lt;- gapminder %&gt;%\n  filter(year == 1952)\n\n# Scatter plot comparing pop and gdpPercap, with both axes on a log scale\nggplot(gapminder_1952,aes(x=pop, y = gdpPercap))+\ngeom_point()+\nscale_x_log10() +\nscale_y_log10()",
    "crumbs": [
      "Data visualization"
    ]
  },
  {
    "objectID": "Data_visualization.html#additional-aesthetics",
    "href": "Data_visualization.html#additional-aesthetics",
    "title": "Data visualization",
    "section": "Additional aesthetics",
    "text": "Additional aesthetics\nYou’ve gained proficiency in creating scatter plots to compare two variables within your data using two visual aesthetics: GDP per capita on the x-axis and life expectancy on the y-axis. However, the gapminder dataset comprises more than just these two variables. For instance, it also includes continent and population. You may wish to explore relationships among all these variables within the same plot.\n\n\n# A tibble: 1,704 × 6\n   country     continent  year lifeExp      pop gdpPercap\n   &lt;fct&gt;       &lt;fct&gt;     &lt;int&gt;   &lt;dbl&gt;    &lt;int&gt;     &lt;dbl&gt;\n 1 Afghanistan Asia       1952    28.8  8425333      779.\n 2 Afghanistan Asia       1957    30.3  9240934      821.\n 3 Afghanistan Asia       1962    32.0 10267083      853.\n 4 Afghanistan Asia       1967    34.0 11537966      836.\n 5 Afghanistan Asia       1972    36.1 13079460      740.\n 6 Afghanistan Asia       1977    38.4 14880372      786.\n 7 Afghanistan Asia       1982    39.9 12881816      978.\n 8 Afghanistan Asia       1987    40.8 13867957      852.\n 9 Afghanistan Asia       1992    41.7 16317921      649.\n10 Afghanistan Asia       1997    41.8 22227415      635.\n# ℹ 1,694 more rows\n\n\nSo far, you’ve allocated the x-axis for GDP per capita and the y-axis for life expectancy. Now, you’ll enhance your scatter plot by incorporating two additional aesthetics: color and size, enabling you to convey even more information. Continent is a categorical variable, with specific values like Asia and Europe.\n\n\n\n\n\n\nThe color aesthetic\n\n\n\n\n\n\nggplot(gapminder_2007, aes(x = gdpPercap, y = lifeExp, color = continent)) +\n  geom_point() +\n  scale_x_log10()\n\n\n\n\n\n\n\n\nA useful approach to represent a categorical variable in a scatter plot is through the color of your points, as demonstrated here. To employ this aesthetic, you include color = continent inside the aes, alongside x = gdpPercap and y = life expectancy. The code structure remains consistent, featuring + geom_point and + scale_x_log10. Note that ggplot2 automatically includes a legend in the plot, elucidating which color corresponds to each continent. This effectively communicates disparities between continents, such as the tendency for African countries, shown in red, to exhibit lower average life expectancy and GDP per capita, contrasting with European countries, depicted in blue, which tend to have higher values.\n\n\n\n\n\n\n\n\n\nThe size aesthestic\n\n\n\n\n\n\nggplot(gapminder_2007, aes(x = gdpPercap, y = lifeExp, color = continent,size = pop)) +\n  geom_point() +\n  scale_x_log10()\n\n\n\n\n\n\n\n\nAnother variable worth incorporating into the graph is population, represented by the pop variable in the dataset. As this is a numeric variable, an effective method to represent it is by adjusting the size of the points in the scatterplot, with countries having higher populations being depicted with larger points. Similar to x, y, and color, you include size = pop within the aes. Note that for readability, we’ve separated the size aesthetic onto a second line. However, this doesn’t alter the functionality, and you need not adhere to this formatting in the exercises.\n\n\n\n\nExercise: Additional aesthetics\n\n\n\n\n\n\nExercise: Adding color to a scatter plot\n\n\n\nIn this lesson you learned how to use the color aesthetic, which can be used to show which continent each point in a scatter plot represents.\n\nCreate a scatter plot with population (pop) on the x-axis, life expectancy (lifeExp) on the y-axis, and with continent (continent) represented by the color of the points. Put the x-axis on a log scale.\n\n\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\ngapminder_1952 &lt;- gapminder %&gt;%\n  filter(year == 1952)\n\n# Scatter plot comparing pop and lifeExp, with color representing continent\nggplot(gapminder_1952, aes(x = pop, y = lifeExp, color = continent))+\ngeom_point()+\nscale_x_log10()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nExercise: Adding size and color to a plot\n\n\n\nIn the last exercise, you created a scatter plot communicating information about each country’s population, life expectancy, and continent. Now you’ll use the size of the points to communicate even more.\n\nModify the scatter plot so that the size of the points represents each country’s GDP per capita (gdpPercap).\n\n\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\ngapminder_1952 &lt;- gapminder %&gt;%\n  filter(year == 1952)\n\n# Add the size aesthetic to represent a country's gdpPercap\nggplot(gapminder_1952, aes(x = pop, y = lifeExp, color = continent, size = gdpPercap)) +\n  geom_point() +\n  scale_x_log10()",
    "crumbs": [
      "Data visualization"
    ]
  },
  {
    "objectID": "Data_visualization.html#faceting",
    "href": "Data_visualization.html#faceting",
    "title": "Data visualization",
    "section": "Faceting",
    "text": "Faceting\n\n\n\n\n\n\nFaceting\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nggplot2 lets you divide your plot into subplots to get one smaller graph for each continent: Africa, the Americas, and so on. This is called faceting, and it’s another powerful way to communicate relationships within your data.\n\nggplot(gapminder_2007, aes(x = gdpPercap, y = lifeExp)) +\ngeom_point() +\nscale_x_log10() +\nfacet_wrap(~ continent)\n\nYou facet a plot by adding another option, with a +, to the end of your code, after geom_point and scale_x_log10. You add facet underscore wrap, then “tilde continent” within the parentheses. In R, the tilde symbol (~) typically means “by”, meaning that we’re splitting the plot by continent, and you can usually find it on the upper left of your keyboard. This tells ggplot2 to divide the data into subplots based on the continent variable.\n\n\n\n\nExercise:Faceting Plots\n\n\n\n\n\n\nExercise: Creating a subgraph for each continent\n\n\n\nFaceting is a powerful tool, and in the following exercises you’ll see how you can use faceting not just to compare among continents, but to compare between all of the years in our dataset. - Create a scatter plot of gapminder_1952 with the x-axis representing population (pop), the y-axis representing life expectancy (lifeExp), and faceted to have one subplot per continent (continent). Put the x-axis on a log scale.\n\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\ngapminder_1952 &lt;- gapminder %&gt;%\n  filter(year == 1952)\n\n# Scatter plot comparing pop and lifeExp, faceted by continent\nggplot(gapminder_1952, aes(x = pop, y = lifeExp)) +\ngeom_point() +\nscale_x_log10() +\nfacet_wrap(~ continent)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nExercise: Faceting by year\n\n\n\nAll of the graphs in this chapter have been visualizing statistics within one year. Now that you’re able to use faceting, however, you can create a graph showing all the country-level data from 1952 to 2007, to understand how global statistics have changed over time.\n\nCreate a scatter plot of the gapminder data:\nPut GDP per capita (gdpPercap) on the x-axis and life expectancy (lifeExp) on the y-axis, with continent (continent) represented by color and population (pop) represented by size.\nPut the x-axis on a log scale\nFacet by the year variable\n\n\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\n# Scatter plot comparing gdpPercap and lifeExp, with color representing continent\n# and size representing population, faceted by year\nggplot(gapminder, aes( x = gdpPercap, y = lifeExp, color = continent, size = pop)) +\ngeom_point() +\nscale_x_log10()+\nfacet_wrap(~ year)",
    "crumbs": [
      "Data visualization"
    ]
  },
  {
    "objectID": "Grouping_and_summarizing.html",
    "href": "Grouping_and_summarizing.html",
    "title": "Grouping and summarizing",
    "section": "",
    "text": "The summarize verb",
    "crumbs": [
      "Grouping and summarizing"
    ]
  },
  {
    "objectID": "Grouping_and_summarizing.html#the-group_by-verb",
    "href": "Grouping_and_summarizing.html#the-group_by-verb",
    "title": "Grouping and summarizing",
    "section": "The group_by verb",
    "text": "The group_by verb\n\n\nThe group_by verb\n\n\n\n\n\n\ngroup_by verb\n\n\n\n\n\nIn the last set of exercises, you learned to use the summarize verb summarize verb to answer questions about the entire dataset, or about a particular year. For example, here you’re finding the average life expectancy and the total population in the year 2007.\n\ngapminder %&gt;%\n  filter(year == 2007) %&gt;%\n  summarize(meanLifeExp = mean(lifeExp),\n  totalPop = sum(pop))\n\n# A tibble: 1 × 2\n  meanLifeExp   totalPop\n        &lt;dbl&gt;      &lt;dbl&gt;\n1        67.0 6251013179\n\n\nWhat if we weren’t interested just in the average for the year 2007, but for each of the years in the dataset? You could rerun this code and change the year each time, but that’s very tedious. Instead, you can use the group_by verb, which tells dplyr to summarize within groups instead of summarizing the entire dataset.\n\n\n\n\n\nSummarizing by year\n\n\n\n\n\n\nSummarizing by year\n\n\n\n\n\n\ngapminder %&gt;%\n  group_by(year) %&gt;%\n  summarize(meanLifeExp = mean(lifeExp),\n  totalPop = sum(pop))\n\n# A tibble: 12 × 3\n    year meanLifeExp   totalPop\n   &lt;int&gt;       &lt;dbl&gt;      &lt;dbl&gt;\n 1  1952        49.1 2406957150\n 2  1957        51.5 2664404580\n 3  1962        53.6 2899782974\n 4  1967        55.7 3217478384\n 5  1972        57.6 3576977158\n 6  1977        59.6 3930045807\n 7  1982        61.5 4289436840\n 8  1987        63.2 4691477418\n 9  1992        64.2 5110710260\n10  1997        65.0 5515204472\n11  2002        65.7 5886977579\n12  2007        67.0 6251013179\n\n\nNotice that this replaces the filter year equals 2007 with group_by year. group_by(year) tells the summarize step that it should perform the summary within each year: within 1952, then within 1957, then within 1962, and combine the results. Instead of getting one row overall, you now get one row for each year. There’s now a year variable along with the new meanLifeExp and totalPop variables. This shows us that the total population started at 2-point-4 billion, and went up to 6-point-25 billion in 2007. We can also see that average life expectancy went up from 49 years in 1952 to 67. You can summarize by other variables besides year. Suppose you’re\n\n\n\n\n\nSummarizing by continent\n\n\n\n\n\n\nSummarizing by continent\n\n\n\n\n\n\ngapminder %&gt;%\n  filter(year == 2007) %&gt;%\n  group_by(continent) %&gt;%\n  summarize(meanLifeExp = mean(lifeExp),\n  totalPop = sum(pop))\n\n# A tibble: 5 × 3\n  continent meanLifeExp   totalPop\n  &lt;fct&gt;           &lt;dbl&gt;      &lt;dbl&gt;\n1 Africa           54.8  929539692\n2 Americas         73.6  898871184\n3 Asia             70.7 3811953827\n4 Europe           77.6  586098529\n5 Oceania          80.7   24549947\n\n\ninterested in the average life expectancy and the total population in 2007 within each continent. You can find this by first filtering for the year 2007, grouping by continent (instead of year), and then performing your summary. This results in a table with one row for each continent, with columns for mean life expectancy and total population. We can see that Europe and Oceania have the highest life expectancy, and that Asia and Africa are lower. Now that you’ve calculated these statistics for each continent in 2007, you might be interested in how they changed for each continent over time.\n\n\n\n\n\nSummarizing by continent and year\n\n\n\n\n\n\nSummarizing by continent and year\n\n\n\n\n\n\ngapminder %&gt;%\n  group_by(year, continent) %&gt;%\n  summarize(totalPop = sum(pop),\n  meanLifeExp = mean(lifeExp))\n\n`summarise()` has grouped output by 'year'. You can override using the\n`.groups` argument.\n\n\n# A tibble: 60 × 4\n# Groups:   year [12]\n    year continent   totalPop meanLifeExp\n   &lt;int&gt; &lt;fct&gt;          &lt;dbl&gt;       &lt;dbl&gt;\n 1  1952 Africa     237640501        39.1\n 2  1952 Americas   345152446        53.3\n 3  1952 Asia      1395357351        46.3\n 4  1952 Europe     418120846        64.4\n 5  1952 Oceania     10686006        69.3\n 6  1957 Africa     264837738        41.3\n 7  1957 Americas   386953916        56.0\n 8  1957 Asia      1562780599        49.3\n 9  1957 Europe     437890351        66.7\n10  1957 Oceania     11941976        70.3\n# ℹ 50 more rows\n\n\nTo do so, you can summarize by both year and continent, by adding year comma continent within the group by. Now the output has one row for each combination of a year and continent. For example, we see the total population and average life expectancy in 1952 for Africa, the Americas, Asia, Europe, and Oceania, followed by each of the continent-level summaries for 1957. In the next video, you’ll learn how to visualize this per-year, per-continent data to understand trends over time.\n\n\n\n\n\nExercise: Summarizing by year\nIn a previous exercise, you found the median life expectancy and the maximum GDP per capita in the year 1957. Now, you’ll perform those two summaries within each year in the dataset, using the group_by verb.\n\n\n\n\n\n\nInstructions\n\n\n\n\nFind the median life expectancy (lifeExp) and maximum GDP per capita (gdpPercap) within each year, saving them into medianLifeExp and maxGdpPercap, respectively.\n\n\n\n# A tibble: 12 × 3\n    year medianLifeExp maxGdpPercap\n   &lt;int&gt;         &lt;dbl&gt;        &lt;dbl&gt;\n 1  1952          45.1      108382.\n 2  1957          48.4      113523.\n 3  1962          50.9       95458.\n 4  1967          53.8       80895.\n 5  1972          56.5      109348.\n 6  1977          59.7       59265.\n 7  1982          62.4       33693.\n 8  1987          65.8       31541.\n 9  1992          67.7       34933.\n10  1997          69.4       41283.\n11  2002          70.8       44684.\n12  2007          71.9       49357.\n\n\n\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\nlibrary(gapminder)\nlibrary(dplyr)\n\n# Find median life expectancy and maximum GDP per capita in each year\ngapminder%&gt;%\ngroup_by(year)%&gt;%\nsummarize(medianLifeExp = median(lifeExp), maxGdpPercap = max(gdpPercap))\n\n# A tibble: 12 × 3\n    year medianLifeExp maxGdpPercap\n   &lt;int&gt;         &lt;dbl&gt;        &lt;dbl&gt;\n 1  1952          45.1      108382.\n 2  1957          48.4      113523.\n 3  1962          50.9       95458.\n 4  1967          53.8       80895.\n 5  1972          56.5      109348.\n 6  1977          59.7       59265.\n 7  1982          62.4       33693.\n 8  1987          65.8       31541.\n 9  1992          67.7       34933.\n10  1997          69.4       41283.\n11  2002          70.8       44684.\n12  2007          71.9       49357.",
    "crumbs": [
      "Grouping and summarizing"
    ]
  },
  {
    "objectID": "Grouping_and_summarizing.html#exercise-summarizing-by-continent",
    "href": "Grouping_and_summarizing.html#exercise-summarizing-by-continent",
    "title": "Grouping and summarizing",
    "section": "Exercise: Summarizing by continent",
    "text": "Exercise: Summarizing by continent\nYou can group by any variable in your dataset to create a summary. Rather than comparing across time, you might be interested in comparing among continents. You’ll want to do that within one year of the dataset: let’s use 1957.\n\n\n\n\n\n\nInstructions\n\n\n\n\nFilter the gapminder data for the year 1957. Then find the median life expectancy (lifeExp) and maximum GDP per capita (gdpPercap) within each continent, saving them into medianLifeExp and maxGdpPercap, respectively.\n\n\n\n# A tibble: 5 × 3\n  continent medianLifeExp maxGdpPercap\n  &lt;fct&gt;             &lt;dbl&gt;        &lt;dbl&gt;\n1 Africa             40.6        5487.\n2 Americas           56.1       14847.\n3 Asia               48.3      113523.\n4 Europe             67.6       17909.\n5 Oceania            70.3       12247.\n\n\n\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\nlibrary(gapminder)\nlibrary(dplyr)\n\n# Find median life expectancy and maximum GDP per capita in each continent in 1957\ngapminder%&gt;%\nfilter(year ==1957)%&gt;%\ngroup_by(continent)%&gt;%\nsummarize(medianLifeExp = median(lifeExp), maxGdpPercap = max(gdpPercap))\n\n# A tibble: 5 × 3\n  continent medianLifeExp maxGdpPercap\n  &lt;fct&gt;             &lt;dbl&gt;        &lt;dbl&gt;\n1 Africa             40.6        5487.\n2 Americas           56.1       14847.\n3 Asia               48.3      113523.\n4 Europe             67.6       17909.\n5 Oceania            70.3       12247.\n\n\n\nExercise: Summarizing by continent and year\nInstead of grouping just by year, or just by continent, you’ll now group by both continent and year to summarize within each.\n\n\n\n\n\n\nInstructions\n\n\n\n\nFind the median life expectancy (lifeExp) and maximum GDP per capita (gdpPercap) within each combination of continent and year, saving them into medianLifeExp and maxGdpPercap, respectively.\n\n\n\n`summarise()` has grouped output by 'year'. You can override using the\n`.groups` argument.\n\n\n# A tibble: 60 × 4\n# Groups:   year [12]\n    year continent medianLifeExp maxGdpPercap\n   &lt;int&gt; &lt;fct&gt;             &lt;dbl&gt;        &lt;dbl&gt;\n 1  1952 Africa             38.8        4725.\n 2  1952 Americas           54.7       13990.\n 3  1952 Asia               44.9      108382.\n 4  1952 Europe             65.9       14734.\n 5  1952 Oceania            69.3       10557.\n 6  1957 Africa             40.6        5487.\n 7  1957 Americas           56.1       14847.\n 8  1957 Asia               48.3      113523.\n 9  1957 Europe             67.6       17909.\n10  1957 Oceania            70.3       12247.\n# ℹ 50 more rows\n\n\n\n\n\nlibrary(gapminder)\nlibrary(dplyr)\n\n# Find median life expectancy and maximum GDP per capita in each continent/year combination\ngapminder%&gt;%\ngroup_by(year,continent)%&gt;%\nsummarize(medianLifeExp = median(lifeExp), maxGdpPercap = max(gdpPercap))\n\n`summarise()` has grouped output by 'year'. You can override using the\n`.groups` argument.\n\n\n# A tibble: 60 × 4\n# Groups:   year [12]\n    year continent medianLifeExp maxGdpPercap\n   &lt;int&gt; &lt;fct&gt;             &lt;dbl&gt;        &lt;dbl&gt;\n 1  1952 Africa             38.8        4725.\n 2  1952 Americas           54.7       13990.\n 3  1952 Asia               44.9      108382.\n 4  1952 Europe             65.9       14734.\n 5  1952 Oceania            69.3       10557.\n 6  1957 Africa             40.6        5487.\n 7  1957 Americas           56.1       14847.\n 8  1957 Asia               48.3      113523.\n 9  1957 Europe             67.6       17909.\n10  1957 Oceania            70.3       12247.\n# ℹ 50 more rows",
    "crumbs": [
      "Grouping and summarizing"
    ]
  },
  {
    "objectID": "Grouping_and_summarizing.html#exercise-summarizing-by-continent-and-year",
    "href": "Grouping_and_summarizing.html#exercise-summarizing-by-continent-and-year",
    "title": "Grouping and summarizing",
    "section": "Exercise: Summarizing by continent and year",
    "text": "Exercise: Summarizing by continent and year\nInstead of grouping just by year, or just by continent, you’ll now group by both continent and year to summarize within each.\n\n\n\n\n\n\nInstructions\n\n\n\n\nFind the median life expectancy (lifeExp) and maximum GDP per capita (gdpPercap) within each combination of continent and year, saving them into medianLifeExp and maxGdpPercap, respectively.\n\n\n\n`summarise()` has grouped output by 'year'. You can override using the\n`.groups` argument.\n\n\n# A tibble: 60 × 4\n# Groups:   year [12]\n    year continent medianLifeExp maxGdpPercap\n   &lt;int&gt; &lt;fct&gt;             &lt;dbl&gt;        &lt;dbl&gt;\n 1  1952 Africa             38.8        4725.\n 2  1952 Americas           54.7       13990.\n 3  1952 Asia               44.9      108382.\n 4  1952 Europe             65.9       14734.\n 5  1952 Oceania            69.3       10557.\n 6  1957 Africa             40.6        5487.\n 7  1957 Americas           56.1       14847.\n 8  1957 Asia               48.3      113523.\n 9  1957 Europe             67.6       17909.\n10  1957 Oceania            70.3       12247.\n# ℹ 50 more rows\n\n\n\n\n\nlibrary(gapminder)\nlibrary(dplyr)\n\n# Find median life expectancy and maximum GDP per capita in each continent/year combination\ngapminder%&gt;%\ngroup_by(year,continent)%&gt;%\nsummarize(medianLifeExp = median(lifeExp), maxGdpPercap = max(gdpPercap))\n\n`summarise()` has grouped output by 'year'. You can override using the\n`.groups` argument.\n\n\n# A tibble: 60 × 4\n# Groups:   year [12]\n    year continent medianLifeExp maxGdpPercap\n   &lt;int&gt; &lt;fct&gt;             &lt;dbl&gt;        &lt;dbl&gt;\n 1  1952 Africa             38.8        4725.\n 2  1952 Americas           54.7       13990.\n 3  1952 Asia               44.9      108382.\n 4  1952 Europe             65.9       14734.\n 5  1952 Oceania            69.3       10557.\n 6  1957 Africa             40.6        5487.\n 7  1957 Americas           56.1       14847.\n 8  1957 Asia               48.3      113523.\n 9  1957 Europe             67.6       17909.\n10  1957 Oceania            70.3       12247.\n# ℹ 50 more rows",
    "crumbs": [
      "Grouping and summarizing"
    ]
  },
  {
    "objectID": "Grouping_and_summarizing.html#visualizing-summarized-data",
    "href": "Grouping_and_summarizing.html#visualizing-summarized-data",
    "title": "Grouping and summarizing",
    "section": "Visualizing summarized data",
    "text": "Visualizing summarized data\nVisualizing summarized data 00:00 - 00:21\nIn the previous section you learned to use the group by and summarize verbs to summarize the gapminder data by year, by continent, or by both. Now you’ll learn how to turn those summaries into informative visualizations, by returning to the ggplot2 package.\n\nSummarizing by year\n\n\n\n\n\n\nSummarizing by year\n\n\n\n\n\nIn the last section we summarized data by year, to find the change in population and in mean life expectancy over time. Now instead of viewing the summarized data as a table, let’s save it as an object called by_year, so you can visualize the data using ggplot2.\n\nby_year &lt;- gapminder %&gt;%\n  group_by(year) %&gt;%\n  summarize(totalPop = sum(pop),meanLifeExp = mean(lifeExp))\n\nby_year\n\n# A tibble: 12 × 3\n    year   totalPop meanLifeExp\n   &lt;int&gt;      &lt;dbl&gt;       &lt;dbl&gt;\n 1  1952 2406957150        49.1\n 2  1957 2664404580        51.5\n 3  1962 2899782974        53.6\n 4  1967 3217478384        55.7\n 5  1972 3576977158        57.6\n 6  1977 3930045807        59.6\n 7  1982 4289436840        61.5\n 8  1987 4691477418        63.2\n 9  1992 5110710260        64.2\n10  1997 5515204472        65.0\n11  2002 5886977579        65.7\n12  2007 6251013179        67.0\n\n\n\n\n\n\n\nVisualizing population over time\n\n\n\n\n\n\nVisualizing population over time\n\n\n\n\n\nYou would construct the graph with the three steps of ggplot2: - The data, which is by_year. - The aesthetics, which puts year on the x-axis and total population on the y-axis. - And the type of graph, which in this case is a scatter plot, represented by geom_point.\n\nggplot(by_year, aes(x = year, y = totalPop)) +\ngeom_point()\n\n\n\n\n\n\n\n\nNotice that the steps are the same as when you were graphing countries in a scatter plot, even though it’s a new dataset. The resulting graph of population by year shows the change in the total population, which is going up over time. ggplot2 puts the y-axis is in scientific notation, since showing it with nine zeros would be hard to read. The global starts a little under 3 times 10 to the 9th power- that’s three billion- and goes up to more than 6 billion.\n\n\n\n\n\nStarting y-axis at zero\n\n\n\n\n\n\nStarting y-axis at zero\n\n\n\n\n\nYou might notice that the graph is a little misleading because it doesn’t include zero: you don’t have a sense of how much the population grew relative to where it was when it started. This is a good time to introduce another graphing option.\n\nggplot(by_year, aes(x = year, y = totalPop)) +\n  geom_point() +\n  expand_limits(y = 0)\n\n\n\n\n\n\n\n\nBy adding “expand underscore limits y = 0” to the end of the ggplot call, you can specify that you want the y-axis to start at zero. Notice that you added it to the end just like you would with scale_x_log10, or facet_wrap. Now the graph makes it clearer that the population is almost tripling during this time.\nYou could have created other graphs of summarized data, such as a graph of the average life expectancy over time, by changing the y aesthetic.\n\n\n\n\n\nSummarizing by year and continent\n\n\n\n\n\n\nSummarizing by year and continent\n\n\n\n\n\nSo far you’ve been graphing the by-year summarized data. But you have also learned to summarize after grouping by both year and continent, to see how the changes in population have occurred separately within each continent.\n\nby_year_continent = gapminder %&gt;%\n  group_by(year, continent) %&gt;%\n  summarize(totalPop = sum(pop),\n  meanLifeExp = mean(lifeExp))\n\n`summarise()` has grouped output by 'year'. You can override using the\n`.groups` argument.\n\nby_year_continent \n\n# A tibble: 60 × 4\n# Groups:   year [12]\n    year continent   totalPop meanLifeExp\n   &lt;int&gt; &lt;fct&gt;          &lt;dbl&gt;       &lt;dbl&gt;\n 1  1952 Africa     237640501        39.1\n 2  1952 Americas   345152446        53.3\n 3  1952 Asia      1395357351        46.3\n 4  1952 Europe     418120846        64.4\n 5  1952 Oceania     10686006        69.3\n 6  1957 Africa     264837738        41.3\n 7  1957 Americas   386953916        56.0\n 8  1957 Asia      1562780599        49.3\n 9  1957 Europe     437890351        66.7\n10  1957 Oceania     11941976        70.3\n# ℹ 50 more rows\n\n\n\n\n\n\n\nVisualizing population by year and continent\n\n\n\n\n\n\nVisualizing population by year and continent\n\n\n\n\n\nSince you now have data over time within each continent, you need a way to separate it in a visualization. To do that you can use the color aesthetic you learned about in chapter two. By setting color equals continent, you can show five separate trends on the same graph.\n\nggplot(by_year_continent, aes(x = year, y = totalPop, color = continent)) +\n  geom_point() +\n  expand_limits(y = 0)\n\n\n\n\n\n\n\n\nThis lets us see that Asia was always the most populated continent and has been growing the most rapidly, that Europe has a slower rate of growth, and that Africa has grown to surpass both Europe and the Americas in terms of population.\n\n\n\n\n\nExercise: Visualizing median life expectancy over time\nIn the last chapter, you summarized the gapminder data to calculate the median life expectancy within each year. This code is provided for you, and is saved with as the by_year dataset. Now you can use the ggplot2 package to turn this into a visualization of changing life expectancy over time.\n\nby_year &lt;- gapminder %&gt;%\n  group_by(year) %&gt;%\n  summarize(medianLifeExp = median(lifeExp),\n            maxGdpPercap = max(gdpPercap))\n\nby_year\n\n# A tibble: 12 × 3\n    year medianLifeExp maxGdpPercap\n   &lt;int&gt;         &lt;dbl&gt;        &lt;dbl&gt;\n 1  1952          45.1      108382.\n 2  1957          48.4      113523.\n 3  1962          50.9       95458.\n 4  1967          53.8       80895.\n 5  1972          56.5      109348.\n 6  1977          59.7       59265.\n 7  1982          62.4       33693.\n 8  1987          65.8       31541.\n 9  1992          67.7       34933.\n10  1997          69.4       41283.\n11  2002          70.8       44684.\n12  2007          71.9       49357.\n\n\n\n\n\n\n\n\nInstructions\n\n\n\n\nUse the by_year dataset to create a scatter plot showing the change of median life expectancy over time, with year on the x-axis and medianLifeExp on the y-axis. Be sure to add expand_limits(y = 0) to make sure the plot’s y-axis includes zero.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\nlibrary(gapminder)\nlibrary(dplyr)\nlibrary(ggplot2)\n\nby_year &lt;- gapminder %&gt;%\n  group_by(year) %&gt;%\n  summarize(medianLifeExp = median(lifeExp),\n            maxGdpPercap = max(gdpPercap))\n\n# Create a scatter plot showing the change in medianLifeExp over time\nggplot(by_year,aes(x = year, y = medianLifeExp))+\n  geom_point()+\n  expand_limits(y=0)\n\n\n\n\n\n\n\n\n\n\n\n\n\nExercise: Visualizing median GDP per capita per continent over time\nIn the last exercise you were able to see how the median life expectancy of countries changed over time. Now you’ll examine the median GDP per capita instead, and see how the trend differs among continents.\n\n\n\n\n\n\nInstructions\n\n\n\n\nSummarize the gapminder dataset by continent and year, finding the median GDP per capita (gdpPercap) within each and putting it into a column called medianGdpPercap.\nUse the assignment operator = to save this summarized data as by_year_continent.\n\n\n\n`summarise()` has grouped output by 'continent'. You can override using the\n`.groups` argument.\n\n\n# A tibble: 60 × 3\n# Groups:   continent [5]\n   continent  year medianGdpPercap\n   &lt;fct&gt;     &lt;int&gt;           &lt;dbl&gt;\n 1 Africa     1952            987.\n 2 Africa     1957           1024.\n 3 Africa     1962           1134.\n 4 Africa     1967           1210.\n 5 Africa     1972           1443.\n 6 Africa     1977           1400.\n 7 Africa     1982           1324.\n 8 Africa     1987           1220.\n 9 Africa     1992           1162.\n10 Africa     1997           1180.\n# ℹ 50 more rows\n\n\n\nCreate a scatter plot showing the change in medianGdpPercap by continent over time. Use color to distinguish between continents, and be sure to add expand_limits(y = 0) so that the y-axis starts at zero.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\nlibrary(gapminder)\nlibrary(dplyr)\nlibrary(ggplot2)\n\n# Summarize medianGdpPercap within each continent within each year: by_year_continent\n\nby_year_continent = gapminder%&gt;%\n                        group_by(continent, year)%&gt;%\n                        summarize(medianGdpPercap = median(gdpPercap))\n\n`summarise()` has grouped output by 'continent'. You can override using the\n`.groups` argument.\n\n# Plot the change in medianGdpPercap in each continent over time\nggplot(by_year_continent, aes(x = year, y = medianGdpPercap,color = continent))+\n  geom_point()+\n  expand_limits(y = 0)\n\n\n\n\n\n\n\n\n\n\n\n\n\nExercise: Comparing median life expectancy and median GDP per continent in 2007\nIn these exercises you’ve generally created plots that show change over time. But as another way of exploring your data visually, you can also use ggplot2 to plot summarized data to compare continents within a single year.\n\n\n\n\n\n\nInstructions\n\n\n\n\nFilter the gapminder dataset for the year 2007, then summarize the median GDP per capita and the median life expectancy within each continent, into columns called medianLifeExp and medianGdpPercap. Save this as by_continent_2007.\n\n\n\n# A tibble: 5 × 3\n  continent medianLifeExp medianGdpPercap\n  &lt;fct&gt;             &lt;dbl&gt;           &lt;dbl&gt;\n1 Africa             52.9           1452.\n2 Americas           72.9           8948.\n3 Asia               72.4           4471.\n4 Europe             78.6          28054.\n5 Oceania            80.7          29810.\n\n\n\nUse the by_continent_2007 data to create a scatterplot comparing these summary statistics for continents in 2007, putting the median GDP per capita on the x-axis to the median life expectancy on the y-axis. Color the scatter plot by continent. You don’t need to add expand_limits(y = 0) for this plot.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\nlibrary(gapminder)\nlibrary(dplyr)\nlibrary(ggplot2)\n\n# Summarize the median GDP and median life expectancy per continent in 2007\nby_continent_2007 = gapminder%&gt;%\n                    filter(year ==2007)%&gt;%\n                    group_by(continent)%&gt;%\n                    summarize(medianLifeExp = median(lifeExp), medianGdpPercap = median(gdpPercap))\n\n# Use a scatter plot to compare the median GDP and median life expectancy\nggplot(by_continent_2007, aes(x = medianGdpPercap, y = medianLifeExp,colot = continent))+\ngeom_point()",
    "crumbs": [
      "Grouping and summarizing"
    ]
  },
  {
    "objectID": "Types_of_visualizations.html",
    "href": "Types_of_visualizations.html",
    "title": "Types of visualizations",
    "section": "",
    "text": "Line plots\nYou’ll start by making a line plot, for visualizing a change over time.\nIn the last chapter, you created a plot like this to show the mean life expectancy in each continent in each year.\nYou can get a sense of the trends from this plot. But it’s a bit easier to understand as a line plot, where the observations within each continent are connected. This makes it clearer that what we care about is the upward or downward trend over time.",
    "crumbs": [
      "Types of visualizations"
    ]
  },
  {
    "objectID": "Types_of_visualizations.html#line-plots",
    "href": "Types_of_visualizations.html#line-plots",
    "title": "Types of visualizations",
    "section": "",
    "text": "Line plots\n\n\n\n\n\n\nLine plots\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nThe way you make a line plot is to change one part of the code. geom_point() was the part of the code that specified you were making a scatter plot. Simply change that to geom_line() to make a line plot.\nSo this is how you make a line plot.\n\nggplot(by_year_continent, aes(x = year, y = medianLifeExp,color = continent))+\n  geom_line()+\n  expand_limits(y = 0)\n\nMost of it looks exactly the same as a scatter plot: provide the data you’re plotting, the aesthetics of x, y, and color, and end with expand_limits(y = 0). The only difference is the type of plot: geom underscore line().\n\n\n\n\n\nExercise: Visualizing median GDP per capita over time\nA line plot is useful for visualizing trends over time. In this exercise, you’ll examine how the median GDP per capita has changed over time.\n\n\n\n\n\n\nInstructions\n\n\n\n\nUse group_by() and summarize() to find the median GDP per capita within each year, calling the output column medianGdpPercap. Use the assignment operator = to save it to a dataset called by_year.\n\n\n# Summarize the median gdpPercap by year, then save it as by_year\nby_year = gapminder%&gt;%\n            group_by(year)%&gt;%\n            summarize(medianGdpPercap = median(gdpPercap))\nby_year\n\n# A tibble: 12 × 2\n    year medianGdpPercap\n   &lt;int&gt;           &lt;dbl&gt;\n 1  1952           1969.\n 2  1957           2173.\n 3  1962           2335.\n 4  1967           2678.\n 5  1972           3339.\n 6  1977           3799.\n 7  1982           4216.\n 8  1987           4280.\n 9  1992           4386.\n10  1997           4782.\n11  2002           5320.\n12  2007           6124.\n\n\n\nUse the by_year dataset to create a line plot showing the change in median GDP per capita over time. Be sure to use expand_limits(y = 0) to include 0 on the y-axis.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\n# Summarize the median gdpPercap by year, then save it as by_year\nby_year = gapminder%&gt;%\n            group_by(year)%&gt;%\n            summarize(medianGdpPercap = median(gdpPercap))\n\n# Create a line plot showing the change in medianGdpPercap over time\n\nggplot(by_year, aes(x = year, y = medianGdpPercap))+\n  geom_line()+\n  expand_limits(y=0)\n\n\n\n\n\n\n\n\n\n\n\n\n\nExercise: Visualizing median GDP per capita by continent over time\nIn the last exercise you used a line plot to visualize the increase in median GDP per capita over time. Now you’ll examine the change within each continent.\n\n\n\n\n\n\nInstructions\n\n\n\n\nUse group_by() and summarize() to find the median GDP per capita within each year and continent, calling the output column medianGdpPercap. Use the assignment operator = to save it to a dataset called by_year_continent.\n\n\n# Summarize the median gdpPercap by year & continent, save as by_year_continent\nsuppressMessages({by_year_continent = gapminder%&gt;%\n                    group_by(year,continent)%&gt;%\n                    summarize(medianGdpPercap = median(gdpPercap))})\nby_year_continent\n\n# A tibble: 60 × 3\n# Groups:   year [12]\n    year continent medianGdpPercap\n   &lt;int&gt; &lt;fct&gt;               &lt;dbl&gt;\n 1  1952 Africa               987.\n 2  1952 Americas            3048.\n 3  1952 Asia                1207.\n 4  1952 Europe              5142.\n 5  1952 Oceania            10298.\n 6  1957 Africa              1024.\n 7  1957 Americas            3781.\n 8  1957 Asia                1548.\n 9  1957 Europe              6067.\n10  1957 Oceania            11599.\n# ℹ 50 more rows\n\n\n\nUse the by_year_continent dataset to create a line plot showing the change in median GDP per capita over time, with color representing continent. Be sure to use expand_limits(y = 0) to include 0 on the y-axis.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\n# Summarize the median gdpPercap by year & continent, save as by_year_continent\nby_year_continent = gapminder%&gt;%\n                    group_by(year,continent)%&gt;%\n                    summarize(medianGdpPercap = median(gdpPercap))\n\n`summarise()` has grouped output by 'year'. You can override using the\n`.groups` argument.\n\n# Create a line plot showing the change in medianGdpPercap by continent over time\nggplot(by_year_continent, aes(x = year, y = medianGdpPercap,color = continent))+\ngeom_line()+\nexpand_limits(y=0)",
    "crumbs": [
      "Types of visualizations"
    ]
  },
  {
    "objectID": "Types_of_visualizations.html#bar-plots",
    "href": "Types_of_visualizations.html#bar-plots",
    "title": "Types of visualizations",
    "section": "Bar plots",
    "text": "Bar plots\nThe next kind of plot you’ll learn to make is a bar plot. Bar plots are useful for comparing values across discrete categories, such as continents.\nIn the last chapter, you learned to calculate summarized values within groups. For example, this code finds the average life expectancy within each continent in the year 2007. That creates a table that looks like this, with one observation for each continent.\n\nby_continent &lt;- gapminder %&gt;%\n  filter(year == 2007) %&gt;%\n  group_by(continent) %&gt;%\n  summarize(meanLifeExp = mean(lifeExp))\n\nby_continent\n\n# A tibble: 5 × 2\n  continent meanLifeExp\n  &lt;fct&gt;           &lt;dbl&gt;\n1 Africa           54.8\n2 Americas         73.6\n3 Asia             70.7\n4 Europe           77.6\n5 Oceania          80.7\n\n\n\nBar plots\n\n\n\n\n\n\nBar plots\n\n\n\n\n\nInstead of just printing the table, you might want to represent the summary visually. For that, you would use a bar plot. This kind of plot represents the data using one bar for each continent, with the height of the bar representing the mean life expectancy.\n\nggplot(by_continent, aes(x = continent, y = meanLifeExp)) +\ngeom_col()\n\n\n\n\n\n\n\n\nTo create a bar plot, you use geom_col(), short for “column”. There are two aesthetics in a bar plot.\n\nX is the categorical variable: in this case, the continent.\nY is the variable that determines the height of the bars: the mean life expectancy.\n\nThis makes it easy to see which continents have higher life expectancy than others. Notice that unlike scatter plots or line plots, bar plots always start at zero.\n\n\n\n\n\nExercise: Visualizing median GDP per capita by continent\nA bar plot is useful for visualizing summary statistics, such as the median GDP in each continent.\n\n\n\n\n\n\nInstructions\n\n\n\n\nUse group_by() and summarize() to find the median GDP per capita within each continent in the year 1952, calling the output column medianGdpPercap.\nUse the assignment operator = to save it to a dataset called by_continent.\n\n\n\n# A tibble: 5 × 2\n  continent medianGdpPercap\n  &lt;fct&gt;               &lt;dbl&gt;\n1 Africa               987.\n2 Americas            3048.\n3 Asia                1207.\n4 Europe              5142.\n5 Oceania            10298.\n\n\n\nUse the by_continent dataset to create a bar plot showing the median GDP per capita in each continent.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\nlibrary(dplyr)\nlibrary(ggplot2)\n\n# Summarize the median gdpPercap by continent in 1952\n\nby_continent = gapminder%&gt;%\n                filter(year == 1952)%&gt;%\n                group_by(continent)%&gt;%\n                summarize(medianGdpPercap = median(gdpPercap))\n# Create a bar plot showing medianGdp by continent\nggplot(by_continent,aes(x = continent,y = medianGdpPercap))+\n  geom_col()\n\n\n\n\n\n\n\n\n\n\n\n\n\nExercise: Visualizing GDP per capita by country in Oceania\nYou’ve created a plot where each bar represents one continent, showing the median GDP per capita for each. But the x-axis of the bar plot doesn’t have to be the continent: you can instead create a bar plot where each bar represents a country.\nIn this exercise, you’ll create a bar plot comparing the GDP per capita between the two countries in the Oceania continent (Australia and New Zealand).\n\n\n\n\n\n\nInstructions\n\n\n\n\nFilter for observations in the Oceania continent in the year 1952. Save this as oceania_1952.\n\n\n\n# A tibble: 2 × 6\n  country     continent  year lifeExp     pop gdpPercap\n  &lt;fct&gt;       &lt;fct&gt;     &lt;int&gt;   &lt;dbl&gt;   &lt;int&gt;     &lt;dbl&gt;\n1 Australia   Oceania    1952    69.1 8691212    10040.\n2 New Zealand Oceania    1952    69.4 1994794    10557.\n\n\n\nUse the oceania_1952 dataset to create a bar plot, with country on the x-axis and gdpPercap on the y-axis.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\nlibrary(gapminder)\nlibrary(dplyr)\nlibrary(ggplot2)\n\n# Filter for observations in the Oceania continent in 1952\noceania_1952 = gapminder%&gt;%\n                filter(year == 1952, continent == 'Oceania')\n\n# Create a bar plot of gdpPercap by country\nggplot(oceania_1952, aes(x = country, y = gdpPercap))+\ngeom_col()",
    "crumbs": [
      "Types of visualizations"
    ]
  },
  {
    "objectID": "Project_Importance_of_Handwashing.html",
    "href": "Project_Importance_of_Handwashing.html",
    "title": "Project: Dr. Semmelweis and the Importance of Handwashing",
    "section": "",
    "text": "Hungarian physician Dr. Ignaz Semmelweis worked at the Vienna General Hospital with childbed fever patients. Childbed fever is a deadly disease affecting women who have just given birth, and in the early 1840s, as many as 10% of the women giving birth died from it at the Vienna General Hospital. Dr.Semmelweis discovered that it was the contaminated hands of the doctors delivering the babies, and on June 1st, 1847, he decreed that everyone should wash their hands, an unorthodox and controversial request; nobody in Vienna knew about bacteria.\nYou will reanalyze the data that made Semmelweis discover the importance of handwashing and its impact on the hospital.\nThe data is stored as two CSV files within the datasets folder.\nyearly_deaths_by_clinic.csv contains the number of women giving birth at the two clinics at the Vienna General Hospital between the years 1841 and 1846.\n\n\n\nColumn\nDescription\n\n\n\n\nyear\nYears (1841-1846)\n\n\nbirths\nNumber of births\n\n\ndeaths\nNumber of deaths\n\n\nclinic\nClinic 1 or clinic 2\n\n\n\nmonthly_deaths.csv contains data from ‘Clinic 1’ of the hospital where most deaths occurred.\n\n\n\nColumn\nDescription\n\n\n\n\ndate\nDate (YYYY-MM-DD)\n\n\nbirths\nNumber of births\n\n\ndeaths\nNumber of deaths\n\n\n\n\n# Imported libraries\nlibrary(tidyverse)\n\nWarning: package 'ggplot2' was built under R version 4.2.3\n\n\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.2     ✔ readr     2.1.4\n✔ forcats   1.0.0     ✔ stringr   1.5.0\n✔ ggplot2   3.5.0     ✔ tibble    3.2.1\n✔ lubridate 1.9.2     ✔ tidyr     1.3.0\n✔ purrr     1.0.1     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors\n\n# Start coding here..\n\n\nLoad the CSV files\nLoad the CSV files into yearly and monthly data frames and check the data.\n\n\nRows: 12 Columns: 4\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (1): clinic\ndbl (3): year, births, deaths\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\n\n# A tibble: 12 × 4\n    year births deaths clinic  \n   &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt; &lt;chr&gt;   \n 1  1841   3036    237 clinic 1\n 2  1842   3287    518 clinic 1\n 3  1843   3060    274 clinic 1\n 4  1844   3157    260 clinic 1\n 5  1845   3492    241 clinic 1\n 6  1846   4010    459 clinic 1\n 7  1841   2442     86 clinic 2\n 8  1842   2659    202 clinic 2\n 9  1843   2739    164 clinic 2\n10  1844   2956     68 clinic 2\n11  1845   3241     66 clinic 2\n12  1846   3754    105 clinic 2\n\n\nRows: 98 Columns: 3\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\ndbl  (2): births, deaths\ndate (1): date\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\n\n# A tibble: 98 × 3\n   date       births deaths\n   &lt;date&gt;      &lt;dbl&gt;  &lt;dbl&gt;\n 1 1841-01-01    254     37\n 2 1841-02-01    239     18\n 3 1841-03-01    277     12\n 4 1841-04-01    255      4\n 5 1841-05-01    255      2\n 6 1841-06-01    200     10\n 7 1841-07-01    190     16\n 8 1841-08-01    222      3\n 9 1841-09-01    213      4\n10 1841-10-01    236     26\n# ℹ 88 more rows\n\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\n# Load and inspect the data\n#yearly = read.csv('datasets/yearly_deaths_by_clinic.csv') # R default function to read csv file\nyearly = read_csv('datasets/yearly_deaths_by_clinic.csv') # read csv file function from tidyverse package\n\nRows: 12 Columns: 4\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (1): clinic\ndbl (3): year, births, deaths\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\nyearly\n\n# A tibble: 12 × 4\n    year births deaths clinic  \n   &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt; &lt;chr&gt;   \n 1  1841   3036    237 clinic 1\n 2  1842   3287    518 clinic 1\n 3  1843   3060    274 clinic 1\n 4  1844   3157    260 clinic 1\n 5  1845   3492    241 clinic 1\n 6  1846   4010    459 clinic 1\n 7  1841   2442     86 clinic 2\n 8  1842   2659    202 clinic 2\n 9  1843   2739    164 clinic 2\n10  1844   2956     68 clinic 2\n11  1845   3241     66 clinic 2\n12  1846   3754    105 clinic 2\n\nmonthly = read_csv(\"datasets/monthly_deaths.csv\")\n\nRows: 98 Columns: 3\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\ndbl  (2): births, deaths\ndate (1): date\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\nmonthly\n\n# A tibble: 98 × 3\n   date       births deaths\n   &lt;date&gt;      &lt;dbl&gt;  &lt;dbl&gt;\n 1 1841-01-01    254     37\n 2 1841-02-01    239     18\n 3 1841-03-01    277     12\n 4 1841-04-01    255      4\n 5 1841-05-01    255      2\n 6 1841-06-01    200     10\n 7 1841-07-01    190     16\n 8 1841-08-01    222      3\n 9 1841-09-01    213      4\n10 1841-10-01    236     26\n# ℹ 88 more rows\n\n\n\n\n\n\n\nAdd a proportion_deaths column\nAdd a proportion_deaths column to each df, calculating the proportion of deaths per number of births for each year in yearly and month in monthly.[proportion_deaths = deaths / births]\n\n\n# A tibble: 12 × 5\n    year births deaths clinic   proportion_deaths\n   &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt; &lt;chr&gt;                &lt;dbl&gt;\n 1  1841   3036    237 clinic 1            0.0781\n 2  1842   3287    518 clinic 1            0.158 \n 3  1843   3060    274 clinic 1            0.0895\n 4  1844   3157    260 clinic 1            0.0824\n 5  1845   3492    241 clinic 1            0.0690\n 6  1846   4010    459 clinic 1            0.114 \n 7  1841   2442     86 clinic 2            0.0352\n 8  1842   2659    202 clinic 2            0.0760\n 9  1843   2739    164 clinic 2            0.0599\n10  1844   2956     68 clinic 2            0.0230\n11  1845   3241     66 clinic 2            0.0204\n12  1846   3754    105 clinic 2            0.0280\n\n\n# A tibble: 98 × 4\n   date       births deaths proportion_deaths\n   &lt;date&gt;      &lt;dbl&gt;  &lt;dbl&gt;             &lt;dbl&gt;\n 1 1841-01-01    254     37           0.146  \n 2 1841-02-01    239     18           0.0753 \n 3 1841-03-01    277     12           0.0433 \n 4 1841-04-01    255      4           0.0157 \n 5 1841-05-01    255      2           0.00784\n 6 1841-06-01    200     10           0.05   \n 7 1841-07-01    190     16           0.0842 \n 8 1841-08-01    222      3           0.0135 \n 9 1841-09-01    213      4           0.0188 \n10 1841-10-01    236     26           0.110  \n# ℹ 88 more rows\n\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\n# Add proportion_deaths to both data frames\nyearly &lt;- yearly %&gt;% \n  mutate(proportion_deaths = deaths / births)\n\nmonthly &lt;- monthly %&gt;% \n  mutate(proportion_deaths = deaths / births)\n\n\n\n\n\n\nCreate two ggplot line plots\nCreate two ggplot line plots: one for the yearly proportion of deaths. Create a different colored line for each clinic.\n\n\n\n\n\n\n\n\n\nAnd another for the monthly proportion of deaths.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\n# Plot the data\nggplot(yearly, aes(x = year, y = proportion_deaths, color = clinic)) +\n  geom_line()\n\n\n\n\n\n\n\n\n\nggplot(monthly, aes(date, proportion_deaths)) +\n  geom_line() +\n  labs(x = \"Year\", y = \"Proportion Deaths\")\n\n\n\n\n\n\n\n\n\n\n\n\n\nAdd a handwashing_started boolean column and plot again\nAdd a handwashing_started boolean column to monthly using June 1st, 1847 as the threshold; TRUE should mean that handwashing has started at the clinic.\n\n# Add the threshold and flag and plot again\nhandwashing_start = as.Date('1847-06-01')\n\nmonthly &lt;- monthly %&gt;%\n  mutate(handwashing_started = date &gt;= handwashing_start)\n\nhead(monthly)\n\n# A tibble: 6 × 5\n  date       births deaths proportion_deaths handwashing_started\n  &lt;date&gt;      &lt;dbl&gt;  &lt;dbl&gt;             &lt;dbl&gt; &lt;lgl&gt;              \n1 1841-01-01    254     37           0.146   FALSE              \n2 1841-02-01    239     18           0.0753  FALSE              \n3 1841-03-01    277     12           0.0433  FALSE              \n4 1841-04-01    255      4           0.0157  FALSE              \n5 1841-05-01    255      2           0.00784 FALSE              \n6 1841-06-01    200     10           0.05    FALSE              \n\ntail(monthly)\n\n# A tibble: 6 × 5\n  date       births deaths proportion_deaths handwashing_started\n  &lt;date&gt;      &lt;dbl&gt;  &lt;dbl&gt;             &lt;dbl&gt; &lt;lgl&gt;              \n1 1848-10-01    299      7            0.0234 TRUE               \n2 1848-11-01    310      9            0.0290 TRUE               \n3 1848-12-01    373      5            0.0134 TRUE               \n4 1849-01-01    403      9            0.0223 TRUE               \n5 1849-02-01    389     12            0.0308 TRUE               \n6 1849-03-01    406     20            0.0493 TRUE               \n\n\nPlot the new df with different colored lines depending on handwashing_started.\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\nggplot(monthly, aes(x = date, y = proportion_deaths, color = handwashing_started)) +\n  geom_line()\n\n\n\n\n\n\n\n\n\n\n\n\n\nCalculate the mean proportion of deaths\nCalculate the mean proportion of deaths before and after handwashing from the monthly data, and store the result as a 2x2 df named monthly_summary with the first column containing the handwashing_started groups and the second column having the mean proportion of deaths.\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\n# Find the mean\nmonthly_summary &lt;- monthly %&gt;% \n  group_by(handwashing_started) %&gt;%\n  summarize(mean_proportion_deaths = mean(proportion_deaths))\n\nmonthly_summary\n\n# A tibble: 2 × 2\n  handwashing_started mean_proportion_deaths\n  &lt;lgl&gt;                                &lt;dbl&gt;\n1 FALSE                               0.105 \n2 TRUE                                0.0211",
    "crumbs": [
      "Project: Dr. Semmelweis and the Importance of Handwashing"
    ]
  },
  {
    "objectID": "Introduction_to_R_Markdown.html",
    "href": "Introduction_to_R_Markdown.html",
    "title": "Introduction to R Markdown",
    "section": "",
    "text": "In this section, we’ll learn how to create reports using R Markdown.\n\nR Markdown\nR Markdown is a tool we use to create efficient reports to summarize analyses and communicate results to an audience. We can create HTML and PDF documents with R Markdown using only R code. R Markdown is also a way to ensure that the results are reproducible, which is important to guarantee when creating reports.\n\n\nR Markdown elements\nAn R Markdown document is made of three components: the code, the text of the report, and the metadata for the file. \n\n\nR Markdown file\nThe YAML header containing the metadata appears at the top of the file, followed by the contents that make up the report, including the text and code in code chunks. YAML is a syntax for hierarchical data structures that is commonly used for configuration files. \n\n\nKnit\nWhen we finish modifying a file and are ready to see the report, we’ll need to knit it. Knitting a file is how we generate an output file from the R markdown file. When a file is knit, R Markdown runs the chunks of R code contained in the file and combines them with the text in the document into an HTML file. For example, when the R Markdown file shown on the left is knit, it will create the output shown on the right.\n\n\nText Formatting\n\n\n\nHeadings\n\n\n\nLinkes and Images\n\n\n\nMore Markdown Basics\nYou will find more about markdown here.",
    "crumbs": [
      "Introduction to R Markdown"
    ]
  },
  {
    "objectID": "Reference.html",
    "href": "Reference.html",
    "title": "Acknowledgements",
    "section": "",
    "text": "I would like to express my gratitude to the following sources for providing valuable materials and inspiration for the creation of this workshop:\nData Analysis and Visualization in R for Ecologists\nIntroduction to the Tidyverse\nReporting with R Markdown\nMarkdown Basics",
    "crumbs": [
      "Acknowledgements"
    ]
  }
]